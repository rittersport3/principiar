)]}'
{"version":3,"file":"/packages/observatory.js","sources":["observatory/lib/codemirror/codemirror.js","observatory/lib/codemirror/javascript.js","observatory/lib/codemirror/coffeescript.js","observatory/mars/observatory.html","observatory/mars/observatoryTemplates.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,6C;AACA,iC;AACA,e;;AAEA,qB;;AAEA,sE;AACA,mC;AACA,qD;AACA,+C;AACA,kF;AACA,kF;AACA,oD;AACA,oE;AACA,oD;AACA,kD;AACA,uD;AACA,kD;AACA,4E;AACA,oF;AACA,sD;;AAEA,+F;AACA,8E;AACA,2G;AACA,kD;AACA,oD;;AAEA,gF;AACA,8D;AACA,4E;AACA,mG;AACA,oD;;AAEA,wD;AACA,0D;;AAEA,gB;;AAEA,uC;AACA,6E;;AAEA,2C;AACA,sE;AACA,+F;AACA,mC;AACA,sC;;AAEA,8E;AACA,8D;AACA,sC;AACA,wB;AACA,uD;;AAEA,8B;AACA,+B;AACA,6B;AACA,mD;AACA,6D;AACA,sC;AACA,4C;;AAEA,uB;AACA,6B;AACA,2D;;AAEA,4B;AACA,2E;AACA,0C;;AAEA,qE;AACA,uC;AACA,yD;;AAEA,gC;AACA,yD;AACA,mD;AACA,4F;AACA,wF;AACA,sB;;AAEA,gC;AACA,qC;AACA,qD;AACA,wD;AACA,oE;AACA,S;AACA,G;;AAEA,wB;;AAEA,yC;AACA,e;;AAEA,iI;AACA,6C;AACA,2C;AACA,gE;AACA,oD;AACA,0F;;AAEA,qC;AACA,6G;AACA,kC;AACA,gG;AACA,+F;AACA,wE;AACA,wD;AACA,2B;AACA,8E;AACA,iF;AACA,yD;AACA,sE;AACA,yF;AACA,gC;AACA,uD;AACA,0F;AACA,6F;AACA,oE;AACA,oD;AACA,sG;AACA,sD;AACA,wD;AACA,2G;AACA,iH;AACA,uC;AACA,uD;AACA,wB;AACA,6D;AACA,uH;AACA,yB;AACA,kE;AACA,8C;AACA,6C;AACA,mE;AACA,0E;AACA,kC;AACA,mF;AACA,+E;;AAEA,+D;AACA,uC;AACA,6C;AACA,wC;AACA,2F;AACA,4F;AACA,wF;;AAEA,kE;AACA,mC;AACA,2C;;AAEA,sE;AACA,0E;AACA,iE;AACA,mC;AACA,qB;AACA,sE;AACA,mE;AACA,2B;AACA,sE;AACA,oE;AACA,mB;AACA,0B;AACA,4C;AACA,2B;AACA,iD;AACA,2B;;AAEA,kD;AACA,4B;AACA,8B;;AAEA,gE;AACA,+C;AACA,kC;;AAEA,sE;AACA,yC;AACA,qB;AACA,wB;AACA,6B;;AAEA,qD;AACA,iE;;AAEA,a;AACA,G;;AAEA,kB;;AAEA,8E;;AAEA,yB;AACA,oE;AACA,gC;AACA,kD;AACA,0C;AACA,O;AACA,mC;AACA,yB;AACA,uB;AACA,gC;AACA,G;;AAEA,gC;AACA,kC;AACA,yD;AACA,2C;AACA,Y;AACA,kG;AACA,2B;AACA,K;AACA,4B;AACA,kB;AACA,oB;AACA,8E;AACA,G;;AAEA,+B;AACA,wE;AACA,uG;AACA,2B;AACA,qC;AACA,iB;AACA,wB;AACA,iE;AACA,U;AACA,kB;AACA,M;AACA,G;;AAEA,oC;AACA,+C;AACA,6B;AACA,gC;AACA,sE;AACA,O;AACA,G;;AAEA,8B;AACA,gD;AACA,kG;AACA,2C;AACA,G;;AAEA,6B;AACA,6F;AACA,uD;AACA,oB;AACA,G;;AAEA,+B;AACA,sB;AACA,kB;AACA,G;;AAEA,8B;AACA,iE;AACA,4B;AACA,4C;AACA,iC;AACA,2F;AACA,oD;AACA,qC;AACA,iE;AACA,O;AACA,K;AACA,4C;AACA,G;;AAEA,kC;AACA,mC;AACA,mD;AACA,gD;AACA,gC;AACA,0C;AACA,yC;AACA,K;AACA,e;AACA,8C;AACA,gC;AACA,6C;AACA,wC;AACA,2C;AACA,K;AACA,e;AACA,G;;AAEA,iC;AACA,qC;AACA,wC;AACA,iD;AACA,4B;AACA,6B;AACA,sC;AACA,kC;AACA,8B;AACA,yB;AACA,O;AACA,O;AACA,G;;AAEA,uD;AACA,kE;AACA,8C;AACA,sB;AACA,sD;AACA,2D;AACA,8C;AACA,4C;AACA,O;AACA,K;AACA,sC;AACA,qD;AACA,G;;AAEA,e;;AAEA,mE;AACA,2C;AACA,yD;AACA,oD;AACA,4E;AACA,sE;AACA,iE;AACA,wD;AACA,iB;AACA,2C;AACA,kF;AACA,4C;AACA,oF;AACA,2C;AACA,iB;AACA,2C;AACA,iF;AACA,2C;AACA,4F;AACA,2C;AACA,2B;AACA,gD;AACA,wG;AACA,gD;;AAEA,sD;AACA,wG;AACA,G;;AAEA,iD;AACA,gF;AACA,oD;AACA,qF;AACA,gD;AACA,yC;AACA,yE;AACA,G;;AAEA,iB;;AAEA,kC;AACA,6B;AACA,kG;AACA,+F;AACA,+D;AACA,qF;AACA,8E;AACA,K;AACA,+B;AACA,2D;AACA,G;;AAEA,2C;AACA,8C;AACA,uG;AACA,8C;AACA,2E;AACA,iG;AACA,oF;AACA,0C;AACA,6F;AACA,iE;AACA,0E;AACA,mE;AACA,kB;AACA,K;AACA,iB;AACA,G;;AAEA,sC;AACA,4E;AACA,G;AACA,0C;AACA,wE;AACA,G;;AAEA,oB;;AAEA,iD;AACA,uE;AACA,4D;AACA,kB;AACA,oC;AACA,6E;AACA,4F;AACA,K;AACA,wB;AACA,gD;;AAEA,mB;AACA,G;;AAEA,8D;AACA,+D;AACA,a;AACA,sD;AACA,2C;AACA,uC;AACA,0D;AACA,6B;AACA,a;AACA,K;;AAEA,qC;AACA,mE;AACA,2D;AACA,uD;AACA,4E;AACA,8B;AACA,6E;AACA,a;;AAEA,uC;AACA,8D;AACA,sF;AACA,2E;;AAEA,oE;AACA,wC;AACA,+B;AACA,8C;AACA,+E;;AAEA,mC;AACA,6E;AACA,mE;AACA,uH;AACA,qG;AACA,4B;AACA,yD;AACA,mE;AACA,K;;AAEA,oE;AACA,qC;AACA,kE;AACA,0D;AACA,oD;AACA,iD;AACA,iE;AACA,kE;AACA,uD;AACA,0B;AACA,+C;AACA,sC;AACA,yE;AACA,8C;AACA,mD;AACA,gD;AACA,S;AACA,O;;AAEA,+C;AACA,wB;AACA,6C;AACA,4B;AACA,+C;AACA,uC;AACA,wD;AACA,gD;AACA,K;AACA,6F;AACA,2B;AACA,a;AACA,K;AACA,0D;;AAEA,yC;AACA,+E;AACA,6D;AACA,uC;AACA,mF;;AAEA,6E;AACA,wD;AACA,mE;AACA,wC;AACA,oE;AACA,uD;AACA,yB;;AAEA,+C;AACA,0G;AACA,mB;AACA,qD;AACA,kC;AACA,yB;AACA,c;AACA,gC;AACA,sC;AACA,O;AACA,8C;AACA,mD;AACA,wC;AACA,+C;AACA,2C;AACA,6D;AACA,2D;AACA,O;AACA,K;AACA,yB;;AAEA,qD;AACA,2C;AACA,gB;AACA,G;;AAEA,iC;AACA,gG;AACA,+E;AACA,4C;AACA,G;;AAEA,2C;AACA,0D;AACA,qE;AACA,wD;AACA,8B;AACA,qD;AACA,uE;AACA,wE;AACA,8B;AACA,gB;AACA,uC;AACA,8D;AACA,mC;AACA,wE;AACA,S;AACA,O;AACA,uB;AACA,K;AACA,kB;AACA,G;;AAEA,8B;AACA,8C;AACA,0E;AACA,iD;AACA,mD;AACA,K;AACA,8C;AACA,oD;AACA,6B;AACA,+B;AACA,iD;AACA,G;;AAEA,kE;AACA,iC;AACA,mE;AACA,sE;AACA,sC;AACA,gE;;AAEA,uB;AACA,kC;AACA,mE;AACA,oC;AACA,4B;AACA,c;AACA,0C;AACA,O;AACA,kB;AACA,K;;AAEA,kD;AACA,0C;AACA,4E;AACA,uC;AACA,wD;AACA,8F;AACA,6C;AACA,2C;AACA,6C;AACA,sE;AACA,uD;AACA,qC;AACA,0B;AACA,a;AACA,sG;AACA,mE;AACA,W;AACA,mF;AACA,mE;AACA,iC;AACA,kD;AACA,wE;AACA,2E;AACA,8B;AACA,c;AACA,oE;AACA,kE;AACA,+C;AACA,kH;AACA,gG;AACA,2C;AACA,sE;AACA,gC;AACA,gD;AACA,gB;AACA,6C;AACA,gC;AACA,S;;AAEA,gC;AACA,O;AACA,c;AACA,O;AACA,8B;AACA,G;;AAEA,4D;AACA,4C;AACA,iE;;AAEA,iG;AACA,yB;;AAEA,qE;AACA,oE;AACA,kB;;AAEA,gB;AACA,6B;AACA,uC;AACA,yD;AACA,6B;AACA,6D;AACA,+B;AACA,gB;AACA,uE;AACA,0D;AACA,kE;AACA,8C;AACA,yD;AACA,4B;AACA,8D;AACA,oB;AACA,a;AACA,W;AACA,gE;AACA,S;AACA,O;AACA,uD;AACA,qB;AACA,+C;AACA,O;AACA,K;AACA,gB;AACA,oE;AACA,oC;AACA,K;AACA,oF;AACA,qB;AACA,wG;AACA,4C;AACA,8F;AACA,uH;AACA,0D;AACA,6F;AACA,qF;AACA,iD;AACA,uD;AACA,4D;AACA,kF;AACA,mD;AACA,kB;AACA,6D;AACA,4F;AACA,oB;AACA,0F;AACA,2G;AACA,S;AACA,K;AACA,sC;AACA,+F;AACA,oF;AACA,mD;AACA,uB;AACA,uG;AACA,U;AACA,+B;AACA,oC;AACA,K;AACA,gB;AACA,G;;AAEA,yD;AACA,2B;AACA,2D;AACA,oC;AACA,6C;AACA,gC;AACA,uC;AACA,8D;AACA,O;AACA,sC;AACA,K;AACA,6B;AACA,4B;AACA,uC;AACA,mF;AACA,K;AACA,G;;AAEA,uB;;AAEA,gC;AACA,6B;AACA,0D;AACA,wD;AACA,gC;AACA,Q;AACA,gF;AACA,mB;AACA,+B;AACA,Q;AACA,kD;;AAEA,8E;AACA,2D;AACA,+E;AACA,wF;AACA,uG;AACA,wF;AACA,2G;AACA,G;;AAEA,+B;AACA,sC;AACA,6E;AACA,gD;AACA,8C;AACA,qG;AACA,sC;;AAEA,oB;AACA,6C;AACA,6D;AACA,2D;AACA,yF;AACA,0D;AACA,G;;AAEA,wB;AACA,qC;AACA,6D;AACA,qD;AACA,kF;;AAEA,4C;AACA,2B;AACA,wG;AACA,iH;AACA,wE;AACA,K;;AAEA,wD;AACA,uC;AACA,8E;AACA,2B;AACA,6D;AACA,O;;AAEA,qH;AACA,2D;AACA,4D;AACA,wD;AACA,+E;AACA,uD;AACA,oB;AACA,2F;AACA,S;AACA,gE;AACA,oD;AACA,uF;AACA,qC;AACA,+D;AACA,S;AACA,kB;AACA,K;;AAEA,uC;AACA,yD;AACA,Y;AACA,gD;AACA,iF;AACA,gD;AACA,kC;AACA,6D;AACA,2C;AACA,+B;AACA,4B;AACA,gB;AACA,S;AACA,0C;AACA,O;;AAEA,sC;AACA,uB;AACA,gD;AACA,qD;AACA,c;AACA,oE;AACA,wB;AACA,8C;AACA,2E;AACA,Y;AACA,mD;AACA,qE;;AAEA,uB;AACA,mE;AACA,Y;AACA,wG;;AAEA,uE;AACA,O;AACA,K;;AAEA,yD;AACA,4C;AACA,G;;AAEA,oB;AACA,6B;AACA,6B;AACA,mC;AACA,kB;AACA,gF;AACA,8C;AACA,+C;AACA,0G;AACA,mC;AACA,G;;AAEA,qB;;AAEA,kC;AACA,yE;AACA,8D;AACA,G;;AAEA,gC;AACA,qB;AACA,2D;AACA,qD;AACA,8C;AACA,sE;AACA,iC;AACA,uG;AACA,8D;AACA,oC;AACA,qD;AACA,4E;AACA,0G;AACA,uB;AACA,6E;AACA,uF;AACA,S;AACA,qD;AACA,c;AACA,qC;AACA,oF;AACA,O;AACA,qB;AACA,4B;AACA,8C;AACA,oB;AACA,O;AACA,O;AACA,uB;AACA,gC;AACA,gD;AACA,4D;AACA,W;AACA,G;;AAEA,iE;AACA,+D;AACA,6D;AACA,mE;AACA,qB;AACA,iC;AACA,yC;AACA,iE;AACA,gD;AACA,0C;AACA,yC;AACA,sE;AACA,oD;AACA,6B;AACA,6B;AACA,O;AACA,K;AACA,mB;AACA,G;;AAEA,kC;AACA,2C;AACA,4C;AACA,8F;AACA,6C;AACA,4C;AACA,qC;AACA,mC;AACA,uG;AACA,iE;AACA,Y;AACA,O;AACA,iB;AACA,G;;AAEA,yB;;AAEA,oE;AACA,iC;AACA,4H;AACA,wB;AACA,G;;AAEA,4C;AACA,iB;AACA,yC;;AAEA,qC;AACA,wB;AACA,mB;AACA,uC;AACA,K;AACA,8C;AACA,+C;AACA,0C;AACA,G;;AAEA,4C;AACA,4C;AACA,4C;AACA,0B;AACA,2E;AACA,0D;AACA,qF;AACA,4B;AACA,K;AACA,G;;AAEA,kC;AACA,8B;AACA,kD;AACA,mB;AACA,0D;AACA,2C;AACA,8C;AACA,0E;AACA,kE;AACA,uF;AACA,kF;AACA,4B;AACA,K;AACA,mB;AACA,G;;AAEA,uC;AACA,qE;AACA,6C;;AAEA,qE;AACA,iE;AACA,qE;AACA,6D;AACA,sE;AACA,sE;AACA,mE;AACA,sE;AACA,6D;AACA,sE;AACA,gD;AACA,mF;AACA,uD;AACA,gD;AACA,uE;AACA,mE;AACA,8C;AACA,2C;AACA,c;AACA,S;AACA,mC;AACA,O;AACA,gC;AACA,K;;AAEA,+C;;AAEA,yC;AACA,qF;AACA,qE;AACA,mD;AACA,+C;AACA,iD;;AAEA,yE;AACA,8B;AACA,mG;AACA,mD;AACA,mD;AACA,+C;AACA,yC;AACA,yC;AACA,4E;AACA,2C;AACA,6C;AACA,gB;AACA,S;AACA,O;AACA,sD;AACA,6B;AACA,mE;AACA,kF;AACA,K;AACA,mE;AACA,uB;AACA,wD;AACA,K;;AAEA,gB;AACA,G;;AAEA,uC;AACA,2B;AACA,sE;AACA,mC;AACA,0F;AACA,K;AACA,gE;AACA,6E;;AAEA,oC;AACA,oE;AACA,kD;AACA,iE;AACA,G;;AAEA,4B;AACA,4E;AACA,oE;AACA,qC;AACA,mC;AACA,G;;AAEA,wF;AACA,wD;AACA,yG;AACA,kD;AACA,4C;AACA,K;AACA,uC;AACA,oC;AACA,yC;AACA,0D;AACA,4B;AACA,+C;AACA,uG;AACA,4G;AACA,4C;AACA,K;AACA,0C;AACA,gB;AACA,G;;AAEA,kD;AACA,sD;AACA,mF;AACA,G;;AAEA,iE;AACA,mD;AACA,6D;AACA,6B;AACA,wD;AACA,yD;AACA,sD;AACA,K;AACA,+C;AACA,+B;AACA,8C;AACA,4C;AACA,0D;AACA,8D;AACA,8E;AACA,uB;AACA,kE;AACA,gE;AACA,kE;AACA,4G;AACA,mE;AACA,2D;AACA,+B;AACA,oD;AACA,qD;AACA,wF;AACA,iD;AACA,2D;AACA,O;AACA,K;AACA,qD;AACA,4B;AACA,kC;AACA,gB;AACA,G;;AAEA,+C;AACA,gC;AACA,oC;AACA,e;AACA,G;;AAEA,mC;AACA,iC;AACA,qB;AACA,+B;AACA,0D;AACA,uE;AACA,sB;AACA,6F;AACA,qB;;AAEA,c;AACA,yC;AACA,6D;AACA,+C;AACA,8C;AACA,kD;AACA,mC;AACA,U;AACA,qB;AACA,K;AACA,G;;AAEA,uD;AACA,iD;AACA,mE;AACA,+C;;AAEA,uB;AACA,wD;AACA,kD;AACA,uB;AACA,qE;AACA,0D;AACA,6B;AACA,qB;AACA,K;;AAEA,6D;AACA,0D;AACA,2F;;AAEA,+D;AACA,+C;AACA,c;AACA,uF;AACA,gE;AACA,mE;AACA,+E;AACA,0B;AACA,mB;AACA,O;AACA,2D;AACA,iB;AACA,sB;AACA,iF;AACA,O;AACA,iC;AACA,0G;AACA,kF;AACA,K;AACA,G;;AAEA,kB;AACA,gC;AACA,0E;AACA,8B;AACA,+B;AACA,4D;AACA,4B;AACA,oC;AACA,8D;AACA,2C;AACA,O;AACA,4D;AACA,K;AACA,uD;AACA,+C;AACA,sD;AACA,oC;AACA,uB;AACA,G;;AAEA,+B;AACA,wE;AACA,kC;AACA,mC;AACA,+C;AACA,mC;AACA,mD;AACA,uB;AACA,G;;AAEA,e;;AAEA,gE;AACA,oE;AACA,gE;AACA,wD;;AAEA,mB;AACA,+B;AACA,gB;AACA,iE;AACA,uB;AACA,kB;AACA,wB;AACA,0B;AACA,wB;AACA,8B;AACA,2B;AACA,6B;AACA,oB;AACA,M;AACA,uD;AACA,G;;AAEA,6B;AACA,0D;AACA,oB;;AAEA,+C;AACA,6D;AACA,wD;AACA,oF;AACA,qC;AACA,2H;AACA,gE;AACA,sF;AACA,K;AACA,8B;AACA,6B;AACA,wC;AACA,uG;AACA,kD;AACA,iG;AACA,K;AACA,4E;AACA,sF;AACA,6D;AACA,6B;AACA,yG;AACA,6G;AACA,4B;AACA,8B;AACA,+B;AACA,K;AACA,8C;;AAEA,2C;AACA,uC;;AAEA,2E;AACA,uD;AACA,6D;AACA,2D;AACA,kE;;AAEA,gB;AACA,kC;AACA,iC;AACA,8B;AACA,K;AACA,uB;AACA,+C;AACA,8D;AACA,uE;AACA,G;;AAEA,oE;AACA,8B;AACA,uB;AACA,+C;AACA,qC;AACA,kD;AACA,+C;AACA,oB;AACA,M;AACA,G;AACA,4B;AACA,uB;AACA,qD;AACA,0C;AACA,gD;AACA,oD;AACA,oB;AACA,M;AACA,G;AACA,2B;AACA,mC;AACA,mC;AACA,yB;AACA,6C;AACA,kB;AACA,G;;AAEA,6C;AACA,0C;AACA,oD;AACA,+D;AACA,G;;AAEA,mB;;AAEA,yB;AACA,uC;AACA,6D;AACA,oB;AACA,yC;AACA,O;AACA,G;;AAEA,yB;AACA,uB;AACA,kC;AACA,kB;AACA,kC;AACA,2E;AACA,0D;AACA,K;AACA,+B;AACA,G;;AAEA,mE;AACA,6D;AACA,oE;AACA,oE;AACA,oD;AACA,0B;AACA,gG;AACA,iF;AACA,2B;AACA,mE;AACA,2D;AACA,qE;AACA,yD;AACA,mD;AACA,2B;AACA,mB;AACA,K;AACA,2B;AACA,mC;AACA,sB;AACA,8D;AACA,6D;AACA,qC;AACA,gC;AACA,iE;AACA,8E;AACA,mG;AACA,2C;AACA,+E;AACA,qF;;AAEA,uC;AACA,oE;AACA,qC;AACA,iC;AACA,mC;AACA,gB;AACA,G;;AAEA,iC;AACA,wC;AACA,2C;AACA,gC;AACA,+B;AACA,oG;AACA,gD;AACA,kE;AACA,0D;AACA,wE;AACA,6C;AACA,G;;AAEA,2B;AACA,qG;AACA,+B;AACA,G;;AAEA,2B;AACA,kD;AACA,G;;AAEA,mB;;AAEA,sC;AACA,uB;AACA,4D;AACA,gE;AACA,gD;AACA,oD;AACA,O;AACA,mE;AACA,iE;AACA,wC;AACA,gG;;AAEA,yC;AACA,6C;AACA,qD;AACA,+B;AACA,O;AACA,2C;AACA,+C;AACA,O;AACA,2C;AACA,iD;AACA,O;;AAEA,qE;AACA,yE;;AAEA,qF;AACA,2C;AACA,2C;AACA,0C;AACA,4F;;AAEA,yB;AACA,8D;AACA,oD;AACA,sB;AACA,uC;AACA,K;AACA,mC;AACA,oE;AACA,oE;AACA,yD;AACA,2B;AACA,sF;AACA,0C;AACA,2C;AACA,K;AACA,iC;;AAEA,oD;AACA,iF;AACA,oD;AACA,Q;AACA,6C;AACA,qD;AACA,uD;AACA,4C;AACA,0C;;AAEA,uB;AACA,mF;AACA,gB;AACA,K;AACA,8B;AACA,oE;AACA,yC;AACA,wC;AACA,oD;AACA,K;AACA,wC;AACA,sC;AACA,qB;AACA,mB;AACA,O;AACA,qC;AACA,oC;AACA,mB;AACA,O;;AAEA,4B;AACA,kC;AACA,yB;AACA,sC;AACA,0C;AACA,6B;AACA,O;AACA,K;AACA,oC;AACA,qC;;AAEA,wC;AACA,kD;AACA,8D;AACA,uB;AACA,O;AACA,G;;AAEA,sC;AACA,uE;AACA,0B;AACA,+D;AACA,2E;AACA,K;AACA,G;;AAEA,yC;AACA,6B;AACA,mB;AACA,+B;AACA,oF;AACA,oF;AACA,yD;AACA,K;AACA,iD;AACA,0E;AACA,oE;AACA,yD;AACA,G;;AAEA,iC;AACA,2B;AACA,qE;AACA,2B;;AAEA,oC;AACA,oB;AACA,2C;AACA,wE;AACA,O;AACA,a;AACA,K;AACA,qC;AACA,oC;;AAEA,0B;AACA,W;AACA,4D;AACA,a;AACA,W;AACA,gD;AACA,2C;AACA,0B;AACA,a;AACA,K;AACA,wD;AACA,+D;AACA,iB;AACA,mF;;AAEA,uC;;AAEA,yC;AACA,mG;AACA,sB;AACA,0B;AACA,2C;AACA,iC;AACA,wF;AACA,sB;AACA,gD;AACA,0B;AACA,kE;AACA,kD;AACA,mD;;AAEA,qB;AACA,4F;AACA,mF;AACA,gD;AACA,uD;AACA,sC;AACA,0C;AACA,+C;AACA,uF;AACA,+B;AACA,yC;AACA,yB;AACA,S;AACA,S;AACA,0C;AACA,oD;AACA,sC;AACA,mC;AACA,iE;AACA,uC;AACA,4C;AACA,a;AACA,K;AACA,wB;AACA,uE;;AAEA,iD;;AAEA,4B;AACA,6B;AACA,0D;AACA,e;AACA,O;;AAEA,4C;AACA,wC;AACA,6B;AACA,gE;AACA,mF;AACA,0D;AACA,oC;AACA,wG;AACA,qF;AACA,O;AACA,K;;AAEA,8C;AACA,qE;AACA,kE;AACA,oE;AACA,+D;AACA,oB;;AAEA,wB;AACA,+B;AACA,0C;AACA,uB;AACA,8B;AACA,2C;AACA,mB;AACA,sB;AACA,iD;AACA,8D;AACA,0F;AACA,c;AACA,gG;AACA,0D;AACA,0C;AACA,gD;AACA,oB;AACA,gB;AACA,O;AACA,K;;AAEA,sB;AACA,yB;AACA,oC;AACA,6B;AACA,0B;AACA,qB;AACA,uC;AACA,mC;AACA,K;;AAEA,0C;AACA,uC;AACA,qB;AACA,O;AACA,iC;AACA,oC;AACA,gC;AACA,G;;AAEA,sB;AACA,kB;AACA,2G;AACA,a;AACA,wB;AACA,sE;AACA,uC;AACA,oE;AACA,sD;AACA,wC;AACA,oC;AACA,oC;AACA,kC;AACA,4B;AACA,uC;AACA,mH;AACA,W;AACA,U;AACA,gC;AACA,Q;AACA,wD;AACA,Y;AACA,6E;AACA,qG;AACA,iC;AACA,0C;AACA,6C;AACA,e;AACA,O;AACA,W;AACA,kD;AACA,mB;AACA,+D;AACA,yC;AACA,uF;AACA,mD;AACA,yB;AACA,sB;AACA,S;AACA,O;AACA,gB;AACA,K;AACA,G;;AAEA,iC;AACA,6B;AACA,+C;AACA,8B;;AAEA,uE;AACA,wB;AACA,oD;;AAEA,2C;AACA,yC;AACA,2C;;AAEA,yD;AACA,4C;AACA,wC;AACA,4C;AACA,2C;AACA,4D;AACA,c;AACA,O;AACA,K;AACA,gB;AACA,G;;AAEA,+B;AACA,6C;;AAEA,gC;AACA,wC;;AAEA,yD;AACA,qG;AACA,sC;AACA,4E;AACA,kB;AACA,mC;AACA,4C;AACA,iF;AACA,iC;AACA,O;AACA,mB;AACA,iC;AACA,mC;AACA,gB;AACA,mC;AACA,iG;AACA,8C;AACA,S;AACA,O;AACA,6C;AACA,iD;AACA,K;AACA,G;;AAEA,kC;AACA,qD;AACA,2B;AACA,2C;AACA,kF;AACA,sF;AACA,qC;AACA,G;AACA,+C;AACA,8F;AACA,2F;AACA,4B;AACA,0B;AACA,oF;AACA,wF;AACA,G;;AAEA,8D;AACA,mE;AACA,oE;AACA,kE;AACA,mE;AACA,wB;AACA,I;AACA,oE;AACA,kE;AACA,mD;;AAEA,kD;AACA,mE;AACA,oE;AACA,kE;AACA,oC;AACA,oC;AACA,0C;AACA,4C;AACA,6C;;AAEA,iC;AACA,+C;AACA,6E;AACA,2E;AACA,2C;;AAEA,qE;AACA,kE;AACA,kE;AACA,8B;AACA,8B;AACA,qE;AACA,0B;AACA,8C;AACA,gB;AACA,S;AACA,O;AACA,K;;AAEA,wD;AACA,mE;AACA,iE;AACA,6D;AACA,8D;AACA,sE;AACA,iC;AACA,+D;AACA,a;AACA,uI;AACA,qI;AACA,0B;AACA,sE;AACA,a;AACA,K;;AAEA,2C;AACA,2C;AACA,2E;AACA,2D;AACA,4D;AACA,qD;AACA,K;;AAEA,4B;AACA,wC;AACA,wF;AACA,mD;AACA,+B;AACA,kD;AACA,+D;AACA,8D;AACA,iF;AACA,oE;AACA,2D;AACA,8B;AACA,iG;AACA,yB;AACA,gB;AACA,c;AACA,qD;AACA,O;AACA,K;AACA,G;;AAEA,kD;AACA,mC;AACA,8B;AACA,+B;AACA,K;AACA,sE;AACA,sC;AACA,gF;AACA,8D;AACA,S;AACA,wD;AACA,2C;AACA,+B;AACA,e;AACA,gC;AACA,qC;AACA,K;AACA,gB;AACA,G;;AAEA,2B;AACA,yC;AACA,iC;AACA,iE;AACA,gB;AACA,G;;AAEA,sB;AACA,oC;AACA,qC;AACA,sE;AACA,kC;AACA,4E;AACA,mD;AACA,qE;AACA,W;;AAEA,iD;AACA,4B;AACA,iC;;AAEA,qB;AACA,qE;AACA,qE;AACA,qD;AACA,uG;AACA,sD;AACA,gG;AACA,mB;AACA,Y;AACA,yF;AACA,K;AACA,2C;;AAEA,kB;AACA,0B;AACA,uB;AACA,8D;AACA,K;AACA,mB;AACA,G;;AAEA,yC;AACA,2D;AACA,kF;AACA,kB;AACA,0B;AACA,uB;AACA,K;AACA,mB;AACA,G;;AAEA,4B;AACA,yB;AACA,kB;AACA,uC;AACA,yD;AACA,+E;AACA,yB;AACA,0C;AACA,gD;AACA,4D;AACA,0C;AACA,gB;AACA,6C;AACA,yE;AACA,mF;AACA,gC;AACA,K;AACA,G;;AAEA,0B;AACA,kB;AACA,+E;AACA,mD;AACA,iG;AACA,4F;AACA,wE;AACA,oE;AACA,wD;AACA,qD;AACA,+F;AACA,6C;AACA,iB;AACA,G;;AAEA,wB;AACA,kD;AACA,4B;AACA,8B;AACA,8B;AACA,8E;AACA,8D;AACA,2B;AACA,K;AACA,iB;AACA,qB;AACA,G;AACA,uB;AACA,2B;AACA,6B;AACA,+B;AACA,qG;AACA,K;AACA,sC;AACA,mF;AACA,G;;AAEA,yB;AACA,iC;AACA,+C;AACA,0C;;AAEA,0E;AACA,qD;AACA,mF;AACA,oD;;AAEA,6C;AACA,iD;AACA,yG;AACA,+F;AACA,oH;AACA,mB;AACA,yB;AACA,8C;AACA,+E;;AAEA,uB;AACA,mD;AACA,2C;AACA,wF;AACA,mB;;AAEA,mD;AACA,oE;AACA,yC;AACA,6G;AACA,gC;AACA,qF;AACA,8B;AACA,4E;AACA,kD;AACA,wE;AACA,8B;AACA,U;AACA,mD;AACA,O;AACA,K;;AAEA,6B;AACA,gB;AACA,gC;AACA,wC;AACA,+B;AACA,Q;AACA,qC;AACA,Y;AACA,6B;AACA,K;AACA,G;;AAEA,a;;AAEA,8B;AACA,yD;AACA,yF;AACA,G;;AAEA,+D;AACA,6C;AACA,6D;AACA,8E;AACA,2C;AACA,yE;AACA,uF;AACA,+D;AACA,K;AACA,0C;AACA,sG;AACA,gF;AACA,6C;AACA,sF;AACA,G;;AAEA,0D;AACA,qD;AACA,+E;AACA,+D;AACA,4D;;AAEA,yE;;AAEA,gC;AACA,kE;AACA,uD;;AAEA,kE;AACA,mC;AACA,gD;AACA,+C;;AAEA,sG;AACA,kE;AACA,2B;AACA,M;AACA,8E;AACA,G;;AAEA,sC;AACA,e;AACA,sB;AACA,wB;AACA,oB;AACA,wB;AACA,4B;AACA,gD;AACA,iD;AACA,2C;AACA,mC;AACA,uD;AACA,Q;AACA,kD;AACA,M;AACA,0C;AACA,4D;;AAEA,kC;AACA,4E;AACA,G;;AAEA,qE;AACA,mD;AACA,+D;AACA,iB;AACA,sG;AACA,6C;AACA,K;;AAEA,0F;AACA,yC;AACA,0B;AACA,K;;AAEA,kE;AACA,uC;AACA,yG;AACA,gB;AACA,iD;AACA,sF;AACA,uB;AACA,wG;AACA,Y;AACA,mD;AACA,K;AACA,G;;AAEA,yD;AACA,iE;AACA,wE;;AAEA,oF;AACA,qB;;AAEA,+C;AACA,+D;AACA,wC;AACA,kC;AACA,O;AACA,kF;AACA,O;AACA,G;;AAEA,6C;AACA,2B;AACA,iE;AACA,uB;AACA,iD;;AAEA,0F;AACA,8E;AACA,0D;;AAEA,yD;AACA,oC;AACA,2B;AACA,8D;;AAEA,8D;AACA,2E;AACA,0E;AACA,uB;;AAEA,iD;AACA,iE;AACA,0C;AACA,oC;AACA,S;AACA,2E;AACA,S;AACA,K;AACA,G;;AAEA,oC;AACA,qE;AACA,0B;AACA,kE;AACA,qF;AACA,6E;AACA,G;;AAEA,8D;AACA,gC;AACA,kF;;AAEA,qC;AACA,kF;AACA,a;AACA,K;AACA,kD;;AAEA,8C;AACA,uC;AACA,0E;AACA,2B;AACA,uF;AACA,iE;AACA,K;AACA,8B;AACA,gC;AACA,iF;AACA,+D;AACA,K;;AAEA,uE;AACA,6E;AACA,iD;AACA,G;;AAEA,qE;AACA,+E;;AAEA,gE;AACA,mC;AACA,yE;AACA,6D;AACA,sC;AACA,oC;AACA,sB;AACA,S;AACA,S;AACA,K;;AAEA,gE;;AAEA,mC;AACA,gF;AACA,wC;AACA,0C;AACA,iC;AACA,sC;AACA,wC;AACA,qC;AACA,S;AACA,S;AACA,4D;AACA,K;;AAEA,uC;AACA,qD;AACA,yB;;AAEA,iE;AACA,kE;AACA,mD;AACA,mC;AACA,qF;AACA,iC;AACA,yE;AACA,6B;AACA,8C;AACA,K;AACA,G;;AAEA,sD;AACA,uB;AACA,mE;AACA,yD;AACA,4E;AACA,G;;AAEA,oB;;AAEA,0B;AACA,yD;AACA,mC;AACA,G;AACA,uB;;AAEA,iE;AACA,uF;AACA,iD;;AAEA,c;;AAEA,gG;AACA,8B;AACA,uD;AACA,wC;AACA,0E;AACA,8D;AACA,G;AACA,oC;AACA,oB;AACA,kE;AACA,6C;AACA,oB;AACA,G;AACA,8E;;AAEA,sE;AACA,mC;AACA,mD;AACA,0C;AACA,kC;AACA,kB;AACA,6C;AACA,kD;AACA,uB;AACA,sB;AACA,sD;AACA,sB;AACA,S;AACA,O;AACA,2C;AACA,Y;AACA,iD;AACA,K;AACA,kD;AACA,G;;AAEA,qD;AACA,2C;AACA,mD;AACA,qE;AACA,6E;AACA,e;AACA,G;;AAEA,yD;AACA,2D;AACA,+B;AACA,+D;AACA,4H;AACA,8D;AACA,2B;AACA,+B;AACA,K;;AAEA,sB;AACA,0B;AACA,8B;AACA,kD;AACA,oE;AACA,8C;AACA,gE;;AAEA,mE;;AAEA,yC;AACA,oC;AACA,mC;AACA,iC;;AAEA,e;AACA,sE;;AAEA,4C;AACA,G;;AAEA,iC;AACA,uE;AACA,G;;AAEA,iD;AACA,sC;AACA,wB;AACA,yB;AACA,sB;AACA,oD;AACA,6B;AACA,2D;AACA,sD;AACA,oG;AACA,+F;AACA,6C;AACA,kD;AACA,uB;AACA,2C;AACA,2D;AACA,wC;AACA,+B;AACA,kC;AACA,yF;AACA,mC;AACA,wD;AACA,6F;AACA,mC;AACA,e;AACA,4B;AACA,8B;AACA,gF;AACA,uE;AACA,yE;AACA,sG;AACA,sC;AACA,2C;AACA,iB;AACA,yD;AACA,e;AACA,a;AACA,4B;AACA,4B;AACA,W;AACA,S;AACA,iF;AACA,O;AACA,oB;AACA,K;AACA,G;;AAEA,c;;AAEA,qC;AACA,wD;AACA,kC;AACA,4E;AACA,kD;AACA,uH;AACA,uC;AACA,0D;AACA,mB;AACA,0C;AACA,uD;AACA,4E;AACA,O;AACA,8C;AACA,wD;AACA,K;AACA,G;;AAEA,uC;AACA,c;AACA,0D;AACA,kG;AACA,qE;AACA,wC;AACA,8C;AACA,sE;AACA,O;AACA,yC;AACA,gD;AACA,wE;AACA,O;AACA,kC;AACA,K;AACA,G;;AAEA,+C;AACA,2D;AACA,2E;AACA,8E;AACA,G;;AAEA,mD;AACA,uD;AACA,uB;AACA,qH;AACA,2C;AACA,kE;AACA,uE;AACA,8F;;AAEA,0G;AACA,yE;AACA,8C;AACA,mC;AACA,8C;AACA,yB;AACA,yD;AACA,+C;AACA,4C;AACA,K;AACA,kB;AACA,G;;AAEA,2C;AACA,kE;AACA,G;;AAEA,0C;AACA,oI;AACA,qC;AACA,0G;AACA,2G;AACA,G;;AAEA,kB;;AAEA,+C;AACA,qB;AACA,0B;AACA,yB;AACA,4C;AACA,6C;AACA,K;;AAEA,qC;AACA,iF;AACA,iE;AACA,yB;AACA,iG;AACA,gC;AACA,gC;AACA,qB;AACA,O;AACA,K;AACA,wB;AACA,0F;AACA,2B;AACA,8B;AACA,qD;AACA,mC;AACA,qD;AACA,K;AACA,2C;;AAEA,mC;AACA,kC;AACA,qG;AACA,uE;;AAEA,uC;AACA,6F;AACA,2B;AACA,G;;AAEA,uC;AACA,iD;AACA,8E;AACA,6B;AACA,gC;AACA,gD;AACA,qB;AACA,gB;AACA,G;;AAEA,oD;AACA,qC;AACA,qC;AACA,wB;AACA,6B;AACA,yB;AACA,gF;AACA,e;AACA,uC;AACA,K;AACA,oC;AACA,mF;AACA,yB;AACA,6C;AACA,uE;AACA,sD;AACA,yC;AACA,uB;AACA,kB;AACA,K;;AAEA,mC;AACA,8C;AACA,8B;AACA,0B;AACA,gB;AACA,4C;AACA,gE;AACA,sE;AACA,4C;AACA,O;AACA,K;AACA,2D;AACA,yC;AACA,kB;AACA,G;;AAEA,yC;AACA,sC;AACA,yB;AACA,4H;AACA,qF;AACA,gC;AACA,iD;AACA,K;AACA,c;AACA,wC;AACA,iC;AACA,+E;AACA,mB;AACA,K;AACA,kB;AACA,G;;AAEA,kC;AACA,qC;AACA,e;AACA,yE;AACA,yC;AACA,sD;AACA,qE;AACA,+D;AACA,iE;AACA,iE;AACA,K;AACA,gE;AACA,G;;AAEA,iC;AACA,6E;AACA,G;;AAEA,c;;AAEA,iE;AACA,gE;;AAEA,0B;AACA,wF;;AAEA,wC;AACA,wD;AACA,+D;AACA,8B;AACA,gD;AACA,kE;AACA,M;;AAEA,+D;AACA,0C;;AAEA,8B;AACA,mC;AACA,M;AACA,iC;AACA,oC;AACA,2C;AACA,uE;AACA,4B;AACA,sB;AACA,S;AACA,M;;AAEA,yD;AACA,4E;AACA,4E;AACA,gG;AACA,2B;AACA,sB;AACA,O;AACA,mD;AACA,yC;AACA,iD;AACA,2C;AACA,gC;AACA,+B;AACA,0B;AACA,iB;AACA,S;AACA,O;AACA,O;;AAEA,8D;AACA,mC;AACA,2E;AACA,4C;AACA,O;AACA,oE;AACA,O;AACA,oD;AACA,6B;AACA,+E;AACA,gD;AACA,wE;AACA,O;;AAEA,qE;AACA,iE;AACA,+B;AACA,yB;AACA,8B;AACA,uE;AACA,wC;AACA,qE;AACA,oD;AACA,kC;AACA,8C;AACA,O;AACA,kC;AACA,8B;AACA,uC;AACA,yE;AACA,kC;AACA,4B;AACA,M;;AAEA,mC;AACA,yB;AACA,0E;AACA,4C;AACA,M;;AAEA,yC;AACA,kC;AACA,wC;AACA,wE;AACA,2C;AACA,qD;AACA,M;;AAEA,qC;AACA,sE;AACA,M;;AAEA,kC;AACA,gD;AACA,gG;AACA,iG;AACA,gG;AACA,M;;AAEA,uE;;AAEA,sE;AACA,oD;AACA,sE;AACA,kC;AACA,kE;AACA,oB;AACA,S;AACA,O;;AAEA,qD;AACA,iD;AACA,+B;AACA,iE;AACA,8C;AACA,kC;AACA,qE;AACA,S;AACA,Y;AACA,S;AACA,O;;AAEA,gE;AACA,sD;AACA,mG;AACA,0C;AACA,gF;AACA,qC;AACA,oB;AACA,S;AACA,O;;AAEA,mE;AACA,sD;AACA,mG;AACA,6B;AACA,+B;AACA,gD;AACA,c;AACA,6F;AACA,uC;AACA,mC;AACA,S;AACA,oB;AACA,S;AACA,O;;AAEA,oE;AACA,wD;AACA,O;;AAEA,2D;;AAEA,8B;AACA,oC;AACA,iD;AACA,qB;AACA,uC;AACA,+B;AACA,c;AACA,6B;AACA,mC;AACA,O;AACA,wF;AACA,0F;AACA,qC;AACA,M;;AAEA,oG;;AAEA,yD;AACA,iC;AACA,uD;AACA,4C;AACA,uC;AACA,sC;AACA,2B;AACA,sB;AACA,qD;AACA,6E;AACA,oF;AACA,2G;AACA,wG;AACA,4C;AACA,0D;AACA,2B;AACA,6C;AACA,2C;AACA,O;AACA,0D;AACA,8C;AACA,6B;AACA,4D;AACA,iC;AACA,c;AACA,sC;AACA,8F;AACA,sC;AACA,O;AACA,iB;AACA,0F;AACA,M;;AAEA,iD;;AAEA,6D;;AAEA,sD;AACA,kB;AACA,qD;AACA,uE;AACA,2D;AACA,+B;AACA,O;AACA,iB;AACA,M;;AAEA,gD;AACA,kC;AACA,6D;AACA,oF;AACA,U;AACA,0C;AACA,+C;AACA,O;;AAEA,kD;AACA,6B;AACA,4F;AACA,2G;AACA,sC;AACA,O;;AAEA,wD;AACA,kC;AACA,qD;AACA,uE;AACA,oD;AACA,uC;AACA,6B;AACA,gD;AACA,+B;AACA,O;AACA,iB;AACA,M;;AAEA,gD;AACA,6B;AACA,oD;AACA,4D;AACA,kD;;AAEA,iG;AACA,qD;AACA,gC;AACA,O;;AAEA,iC;AACA,uD;AACA,iE;AACA,U;AACA,2G;AACA,M;;AAEA,8C;AACA,kC;AACA,O;AACA,+B;AACA,gE;AACA,iE;AACA,mF;AACA,gG;AACA,M;;AAEA,mC;AACA,oD;AACA,qC;AACA,+D;AACA,qC;AACA,c;AACA,uE;AACA,O;AACA,M;;AAEA,sC;AACA,+B;AACA,sF;AACA,O;AACA,6E;AACA,gF;AACA,qB;AACA,M;;AAEA,+C;AACA,iD;;AAEA,qD;;AAEA,yC;AACA,wB;AACA,qE;AACA,sB;AACA,O;;AAEA,4C;AACA,yB;AACA,oB;AACA,2B;AACA,wB;AACA,2D;AACA,iB;AACA,O;;AAEA,0D;AACA,gE;AACA,kE;AACA,8D;AACA,I;;AAEA,oB;;AAEA,sD;;AAEA,uC;AACA,0C;;AAEA,mD;AACA,sC;AACA,sC;AACA,2F;AACA,G;;AAEA,iF;;AAEA,qE;AACA,+D;AACA,yC;AACA,qB;AACA,W;AACA,0C;AACA,4B;AACA,iB;AACA,W;;AAEA,0C;AACA,kC;AACA,8B;AACA,qC;AACA,iB;AACA,oB;AACA,kB;AACA,W;AACA,gC;AACA,sC;;AAEA,2C;AACA,qB;AACA,uB;AACA,W;AACA,6C;AACA,4B;;AAEA,6B;AACA,8B;;AAEA,uD;AACA,sC;AACA,yC;AACA,uB;AACA,W;AACA,iD;AACA,wF;AACA,iB;AACA,W;AACA,6C;AACA,yC;AACA,uB;AACA,W;AACA,qD;AACA,2F;AACA,kE;;AAEA,+C;AACA,iE;AACA,wC;AACA,K;AACA,2B;;AAEA,iC;AACA,4B;AACA,0B;AACA,2B;AACA,+B;AACA,8B;AACA,8E;AACA,kE;;AAEA,8C;AACA,0C;AACA,K;AACA,4B;;AAEA,iC;;AAEA,qC;AACA,2E;;AAEA,gD;AACA,qF;AACA,+B;AACA,6B;AACA,sF;AACA,K;AACA,uB;AACA,I;;AAEA,gD;AACA,2B;AACA,I;;AAEA,2C;AACA,kE;AACA,6B;AACA,6E;AACA,uD;AACA,qD;AACA,uC;AACA,I;;AAEA,gD;AACA,wC;AACA,oC;AACA,oE;AACA,0C;AACA,mD;AACA,2C;AACA,8B;AACA,iD;AACA,8E;AACA,mC;AACA,O;AACA,K;AACA,6B;AACA,mB;AACA,I;;AAEA,4C;AACA,2D;AACA,K;AACA,8C;;AAEA,sD;AACA,sD;AACA,wG;AACA,8B;AACA,I;;AAEA,e;;AAEA,qD;AACA,sC;AACA,I;;AAEA,mC;;AAEA,qB;AACA,+D;;AAEA,wB;;AAEA,qE;AACA,+B;AACA,mC;AACA,qC;AACA,qD;AACA,oB;AACA,0B;AACA,yB;AACA,qD;AACA,sB;AACA,K;AACA,kB;AACA,G;AACA,mC;;AAEA,qC;AACA,4D;AACA,G;AACA,qC;;AAEA,gD;AACA,4B;AACA,uC;AACA,yB;AACA,uB;AACA,K;AACA,8C;AACA,I;;AAEA,sB;;AAEA,wC;AACA,2F;AACA,4B;AACA,sF;AACA,0D;AACA,oE;AACA,2E;AACA,M;AACA,8B;AACA,kC;AACA,wD;AACA,M;AACA,oC;AACA,oC;AACA,2E;AACA,qE;AACA,+B;AACA,6D;AACA,M;AACA,oC;AACA,gE;AACA,8C;AACA,iC;AACA,0C;AACA,6D;AACA,4E;AACA,mE;AACA,uC;AACA,M;AACA,6B;AACA,2D;AACA,M;AACA,mD;AACA,oD;AACA,mD;AACA,oD;AACA,qD;AACA,qD;AACA,yD;AACA,yD;AACA,qD;AACA,qD;AACA,0D;AACA,wD;AACA,0D;AACA,wD;AACA,4D;AACA,0D;AACA,+D;AACA,0E;AACA,8B;AACA,4D;AACA,sD;AACA,M;AACA,kC;AACA,4D;AACA,iD;AACA,sE;AACA,8E;AACA,M;AACA,oC;AACA,gC;AACA,mD;AACA,uD;AACA,W;AACA,M;AACA,yD;AACA,I;;AAEA,qB;;AAEA,sC;AACA,kB;AACA,yF;AACA,mG;AACA,2G;AACA,4D;AACA,I;AACA,mE;AACA,kD;AACA,sB;AACA,8G;AACA,uG;AACA,gH;AACA,yG;AACA,8G;AACA,mD;AACA,wB;AACA,I;AACA,uB;AACA,yG;AACA,oG;AACA,sH;AACA,yG;AACA,4G;AACA,iD;AACA,oC;AACA,I;AACA,iE;AACA,mB;AACA,kG;AACA,kG;AACA,4G;AACA,+G;AACA,I;;AAEA,oB;;AAEA,2B;AACA,mD;AACA,oB;AACA,G;;AAEA,0C;AACA,0B;AACA,2B;AACA,4B;AACA,yC;AACA,sD;AACA,2C;;AAEA,wC;AACA,4C;AACA,0E;AACA,mC;AACA,2D;AACA,0C;AACA,8B;AACA,O;AACA,mB;AACA,K;;AAEA,2C;AACA,iC;AACA,4B;AACA,K;AACA,G;AACA,iC;AACA,uC;AACA,+E;AACA,G;AACA,oC;AACA,uC;AACA,wD;AACA,2C;AACA,2E;AACA,0E;AACA,2D;AACA,gB;AACA,G;AACA,mC;AACA,2C;AACA,+B;;AAEA,iB;;AAEA,yD;AACA,+B;AACA,mC;AACA,+C;AACA,2C;AACA,sE;AACA,iD;AACA,oC;AACA,mC;AACA,oD;AACA,4D;AACA,iD;AACA,gF;AACA,K;;AAEA,qD;AACA,wB;AACA,wC;AACA,sE;AACA,4C;AACA,2D;AACA,a;AACA,wD;AACA,mB;AACA,qC;AACA,0B;AACA,wC;AACA,Y;AACA,qB;AACA,O;AACA,K;;AAEA,oC;AACA,wC;AACA,mE;AACA,gB;AACA,mB;AACA,qD;AACA,gC;AACA,a;AACA,8D;AACA,kC;AACA,0B;AACA,2C;AACA,sD;AACA,4C;AACA,O;AACA,M;AACA,c;AACA,I;;AAEA,kB;;AAEA,+D;AACA,2B;;AAEA,kD;AACA,0C;AACA,8B;AACA,yB;AACA,gC;AACA,kD;AACA,G;;AAEA,4B;AACA,6D;AACA,4C;AACA,yE;AACA,sB;AACA,wC;AACA,8C;AACA,M;AACA,0B;AACA,4C;AACA,yD;AACA,oE;AACA,sC;AACA,M;AACA,+B;AACA,2B;AACA,+B;AACA,8B;AACA,M;AACA,0B;AACA,2B;AACA,yE;AACA,8B;AACA,M;AACA,2D;AACA,0B;AACA,oD;AACA,sD;AACA,M;AACA,yC;AACA,wB;AACA,4C;AACA,4H;AACA,wC;AACA,O;AACA,kC;AACA,M;AACA,mF;AACA,wD;AACA,uC;AACA,sF;AACA,kE;AACA,8C;AACA,4D;AACA,sB;AACA,S;AACA,c;AACA,+D;AACA,kD;AACA,oE;AACA,qB;AACA,O;AACA,M;AACA,wE;AACA,I;AACA,yC;;AAEA,gB;;AAEA,kC;AACA,oB;AACA,qB;AACA,mB;AACA,G;AACA,qC;;AAEA,2C;AACA,uC;AACA,mD;AACA,mC;AACA,+B;AACA,iD;AACA,+B;AACA,0D;AACA,8C;AACA,kE;AACA,4B;AACA,2B;AACA,qE;AACA,uD;AACA,K;AACA,uG;AACA,uF;AACA,2C;AACA,oC;AACA,uC;AACA,yC;AACA,O;AACA,K;;AAEA,uD;AACA,0B;AACA,kC;AACA,8C;AACA,gC;AACA,mC;AACA,K;AACA,iC;AACA,+B;AACA,I;;AAEA,0C;AACA,iB;AACA,iD;AACA,+B;AACA,0D;AACA,iD;AACA,iC;AACA,4D;AACA,sD;AACA,O;AACA,K;AACA,6C;AACA,wC;AACA,I;;AAEA,0D;AACA,iC;AACA,sC;AACA,mF;AACA,gC;AACA,sC;AACA,4C;AACA,2E;AACA,oC;AACA,kE;AACA,I;;AAEA,oD;AACA,4C;AACA,iC;AACA,+E;AACA,+E;AACA,K;AACA,0B;AACA,I;AACA,oD;AACA,oD;AACA,4C;AACA,iC;AACA,yE;AACA,K;AACA,I;;AAEA,mD;AACA,uF;AACA,kG;;AAEA,2C;AACA,6D;AACA,0C;AACA,8B;AACA,8B;AACA,oF;AACA,K;AACA,mD;;AAEA,oG;AACA,mD;AACA,4G;AACA,6B;AACA,wD;AACA,+B;AACA,uE;AACA,kF;AACA,6B;AACA,8E;AACA,oF;AACA,uC;AACA,O;AACA,gC;AACA,gB;AACA,O;AACA,2E;AACA,6D;AACA,O;;AAEA,0B;AACA,8B;AACA,+D;AACA,2B;AACA,K;AACA,2B;AACA,6C;AACA,kF;AACA,yB;AACA,2B;AACA,K;AACA,a;AACA,uD;AACA,uF;AACA,8C;AACA,8C;AACA,K;AACA,kB;AACA,G;;AAEA,uB;;AAEA,+C;AACA,2B;AACA,2B;AACA,yD;AACA,+B;AACA,uD;AACA,K;AACA,G;AACA,iD;;AAEA,iD;AACA,uC;AACA,kC;AACA,iD;AACA,8B;AACA,+B;AACA,I;AACA,gD;AACA,+B;AACA,I;AACA,gE;AACA,oD;AACA,wB;AACA,iB;AACA,I;;AAEA,yD;AACA,+B;AACA,2B;AACA,iF;AACA,sC;AACA,mC;AACA,gE;AACA,uF;AACA,iD;AACA,2C;AACA,6B;AACA,O;AACA,kD;AACA,G;;AAEA,qB;;AAEA,4C;AACA,uD;AACA,0B;AACA,6C;AACA,K;AACA,G;AACA,0C;AACA,6C;AACA,2D;AACA,a;AACA,G;AACA,sC;AACA,mF;AACA,iC;AACA,G;;AAEA,sD;AACA,uD;AACA,8C;AACA,kH;AACA,wH;AACA,4G;AACA,gD;AACA,+D;AACA,iD;AACA,O;AACA,K;AACA,c;AACA,G;;AAEA,mD;AACA,uD;AACA,8C;AACA,sG;AACA,kH;AACA,gH;AACA,8E;AACA,6E;AACA,iD;AACA,O;AACA,K;AACA,c;AACA,G;;AAEA,gD;AACA,+F;AACA,0F;AACA,2C;;AAEA,iG;AACA,mD;AACA,+D;AACA,0D;;AAEA,iC;AACA,wG;AACA,gB;AACA,uC;AACA,8C;AACA,4B;AACA,8B;AACA,0D;AACA,wC;AACA,mF;AACA,S;AACA,O;AACA,K;AACA,e;AACA,2E;AACA,6C;AACA,2B;AACA,+C;AACA,gC;AACA,2D;AACA,uB;AACA,+B;AACA,6D;AACA,W;AACA,gB;AACA,8B;AACA,2D;AACA,S;AACA,O;AACA,K;;AAEA,6B;AACA,oB;AACA,uC;AACA,mD;AACA,2B;AACA,8C;AACA,kC;AACA,oG;AACA,mC;AACA,oC;AACA,4B;AACA,K;AACA,sB;AACA,G;;AAEA,uC;AACA,uC;AACA,wD;AACA,+B;AACA,+B;;AAEA,0C;AACA,qD;AACA,iC;AACA,4D;AACA,mC;AACA,iD;AACA,gE;AACA,4B;AACA,S;AACA,8B;AACA,4B;AACA,O;AACA,K;AACA,e;AACA,G;;AAEA,gD;AACA,uB;AACA,qD;AACA,+E;AACA,8C;AACA,wE;AACA,iD;AACA,O;AACA,O;AACA,8B;AACA,uC;AACA,8C;AACA,yC;AACA,8C;AACA,yB;AACA,qE;AACA,8B;AACA,kF;AACA,oD;AACA,2E;AACA,gD;AACA,4C;AACA,iC;AACA,O;AACA,K;AACA,iB;AACA,G;;AAEA,sC;AACA,2D;AACA,uD;AACA,kB;AACA,yC;AACA,8C;AACA,0C;AACA,oD;AACA,0B;AACA,K;AACA,iB;AACA,G;AACA,2E;AACA,2F;;AAEA,kC;AACA,e;AACA,+C;AACA,mD;AACA,gB;AACA,G;;AAEA,oC;AACA,oD;AACA,uD;AACA,kB;AACA,yC;AACA,uC;AACA,sF;AACA,oB;AACA,K;AACA,G;AACA,+C;AACA,0B;AACA,wE;AACA,iG;AACA,K;AACA,kE;AACA,kB;AACA,2D;AACA,+B;AACA,sD;AACA,oE;AACA,wD;AACA,K;AACA,G;;AAEA,oC;AACA,iC;AACA,uB;AACA,0C;AACA,uC;AACA,4B;AACA,G;;AAEA,2C;AACA,uB;AACA,0C;AACA,uC;AACA,6B;AACA,G;;AAEA,iB;;AAEA,wE;AACA,6D;AACA,+B;AACA,iB;AACA,qB;AACA,I;AACA,+B;AACA,uB;AACA,kC;AACA,0C;AACA,kD;AACA,kD;AACA,oB;AACA,M;AACA,G;AACA,2D;AACA,uD;AACA,kC;AACA,6E;AACA,6C;AACA,oF;AACA,mC;AACA,K;AACA,6D;AACA,2B;AACA,uB;AACA,yC;AACA,sB;AACA,yD;AACA,+B;AACA,mC;AACA,K;;AAEA,iC;AACA,oD;AACA,wE;AACA,6G;AACA,oD;AACA,G;;AAEA,qD;AACA,mD;AACA,yD;AACA,2C;AACA,yD;AACA,yB;AACA,+D;AACA,kF;AACA,mE;AACA,+D;AACA,O;AACA,kB;AACA,O;AACA,kB;AACA,G;;AAEA,wB;;AAEA,gE;AACA,0C;AACA,wD;AACA,4B;AACA,yC;AACA,4D;AACA,gB;AACA,G;;AAEA,gE;AACA,qB;AACA,gD;AACA,wC;AACA,8C;AACA,4B;AACA,yC;AACA,8D;AACA,oE;AACA,gC;AACA,G;;AAEA,8B;AACA,uB;AACA,4B;AACA,G;;AAEA,+D;AACA,gE;AACA,a;AACA,8C;AACA,yC;AACA,qE;AACA,sC;AACA,4D;AACA,4D;AACA,2B;AACA,4C;AACA,8B;AACA,6B;AACA,mF;AACA,iE;AACA,qB;AACA,O;AACA,oC;AACA,gC;AACA,+C;AACA,0C;AACA,2C;AACA,wC;AACA,K;AACA,sC;AACA,G;;AAEA,2C;AACA,iE;AACA,iE;AACA,gC;AACA,uC;AACA,4F;;AAEA,wC;AACA,wD;AACA,gD;AACA,uE;AACA,wC;AACA,sF;AACA,qB;AACA,6C;AACA,4B;AACA,wB;AACA,kB;AACA,wE;AACA,oB;AACA,W;AACA,iB;AACA,S;AACA,2B;AACA,6B;AACA,kD;AACA,wB;AACA,gB;AACA,yC;AACA,kC;AACA,0D;AACA,W;AACA,S;AACA,S;AACA,K;;AAEA,c;AACA,G;;AAEA,oC;AACA,2D;AACA,gG;AACA,uB;AACA,G;;AAEA,gE;AACA,gD;AACA,yC;AACA,2B;AACA,iE;AACA,iE;AACA,iD;AACA,gC;AACA,gC;AACA,K;AACA,G;;AAEA,6B;AACA,gC;AACA,4B;AACA,sC;AACA,wE;AACA,G;;AAEA,+C;AACA,sE;AACA,iD;AACA,qB;AACA,sD;AACA,yC;AACA,K;;AAEA,sE;AACA,2D;AACA,+D;;AAEA,Q;AACA,oD;AACA,sB;AACA,0E;AACA,0E;AACA,mF;AACA,gC;AACA,O;AACA,2E;AACA,qC;AACA,iB;AACA,6C;AACA,uB;AACA,O;AACA,mB;;AAEA,qC;AACA,kH;AACA,mE;AACA,iE;;AAEA,c;AACA,sE;AACA,mE;AACA,oB;AACA,oD;AACA,+B;AACA,4C;AACA,+C;AACA,wE;AACA,4C;AACA,wG;AACA,iE;AACA,O;AACA,K;;AAEA,uB;AACA,G;;AAEA,6E;AACA,mE;AACA,sB;AACA,wC;AACA,iC;AACA,kD;AACA,Y;AACA,+D;AACA,oB;AACA,0C;AACA,6C;AACA,4D;AACA,sB;AACA,uF;AACA,iC;AACA,S;AACA,sB;AACA,2B;AACA,2B;AACA,+F;AACA,yE;AACA,kC;AACA,gB;AACA,8D;AACA,gE;AACA,qC;AACA,2B;AACA,S;AACA,O;AACA,K;AACA,6D;AACA,kC;AACA,8C;AACA,0C;AACA,wE;AACA,K;AACA,qC;AACA,G;;AAEA,0E;AACA,mD;AACA,2C;AACA,8C;AACA,mE;AACA,kC;AACA,Y;AACA,iC;AACA,sE;AACA,4C;AACA,O;AACA,+C;AACA,sC;AACA,0E;AACA,8D;AACA,0D;AACA,2C;AACA,+E;AACA,gE;AACA,yC;AACA,+B;AACA,K;AACA,6C;AACA,G;;AAEA,sD;AACA,iB;AACA,4D;AACA,sC;AACA,oC;AACA,8C;AACA,gC;AACA,O;AACA,K;AACA,wB;AACA,G;;AAEA,qE;AACA,kC;AACA,qD;AACA,iC;AACA,iB;AACA,8C;AACA,wE;AACA,a;AACA,K;;AAEA,kD;AACA,yC;AACA,2E;AACA,c;AACA,2D;AACA,uD;AACA,gD;AACA,iC;AACA,gD;AACA,2C;AACA,iE;AACA,+F;AACA,4D;AACA,qF;AACA,oF;AACA,gF;AACA,6B;AACA,6D;AACA,iC;AACA,W;AACA,uE;AACA,2C;AACA,S;AACA,wD;AACA,wF;AACA,sF;AACA,mE;AACA,S;AACA,uF;AACA,O;AACA,4B;;AAEA,2C;AACA,oB;AACA,mB;AACA,sC;AACA,2B;AACA,0E;AACA,uF;AACA,uG;AACA,W;AACA,8E;AACA,oB;AACA,8B;AACA,S;AACA,8D;AACA,O;AACA,K;AACA,G;;AAEA,4B;;AAEA,0E;AACA,sE;;AAEA,+D;AACA,8E;AACA,kG;;AAEA,sC;AACA,uD;AACA,gE;AACA,6D;AACA,kE;AACA,mE;AACA,qE;AACA,gD;AACA,qD;AACA,uC;AACA,6B;AACA,wG;AACA,8C;AACA,c;AACA,oE;AACA,qE;AACA,gG;AACA,uG;AACA,yC;AACA,O;AACA,kC;AACA,oG;AACA,8C;AACA,wC;AACA,Y;AACA,qG;AACA,6F;AACA,kE;AACA,mE;AACA,4D;AACA,uC;AACA,K;;AAEA,4C;AACA,kE;AACA,G;;AAEA,6B;AACA,uB;AACA,uB;AACA,+D;AACA,6B;AACA,gC;AACA,K;AACA,yB;AACA,G;;AAEA,yB;AACA,wD;AACA,kC;AACA,gD;AACA,iC;AACA,mC;AACA,0B;AACA,oC;AACA,O;AACA,+B;AACA,M;AACA,+B;AACA,sE;AACA,M;AACA,8C;AACA,4B;AACA,sF;AACA,2E;AACA,M;AACA,gC;AACA,wC;AACA,4C;AACA,K;AACA,I;;AAEA,kC;AACA,6B;AACA,6B;AACA,sD;AACA,2B;AACA,kD;AACA,uB;AACA,K;AACA,qB;AACA,yB;AACA,uB;AACA,G;;AAEA,2B;AACA,gD;AACA,kC;AACA,qB;AACA,sD;AACA,6D;AACA,sB;AACA,kE;AACA,oC;AACA,kD;AACA,8E;AACA,oC;AACA,iB;AACA,wB;AACA,O;AACA,+B;AACA,uB;AACA,6B;AACA,+C;AACA,uC;AACA,O;AACA,M;AACA,+B;AACA,6F;AACA,M;AACA,8C;AACA,gC;AACA,4B;AACA,6D;AACA,6D;AACA,uB;AACA,+C;AACA,uD;AACA,6C;AACA,4E;AACA,mD;AACA,6C;AACA,sD;AACA,oC;AACA,a;AACA,8B;AACA,W;AACA,gB;AACA,S;AACA,iB;AACA,O;AACA,M;AACA,4B;AACA,6C;AACA,oB;AACA,U;AACA,oE;AACA,+C;AACA,mD;AACA,kD;AACA,2B;AACA,wC;AACA,oB;AACA,gB;AACA,kC;AACA,sC;AACA,wD;AACA,6D;AACA,S;AACA,mC;AACA,wC;AACA,6B;AACA,M;AACA,gC;AACA,6D;AACA,6D;AACA,sB;AACA,0C;AACA,qD;AACA,sC;AACA,iB;AACA,wB;AACA,O;AACA,K;AACA,I;;AAEA,oB;AACA,8D;AACA,sE;AACA,yC;;AAEA,kE;AACA,2B;AACA,yC;AACA,0B;AACA,iC;AACA,8B;AACA,kC;AACA,mH;AACA,0B;AACA,2B;;AAEA,yD;AACA,8F;AACA,I;;AAEA,oD;AACA,kC;AACA,2D;AACA,gE;AACA,M;;AAEA,iC;AACA,qB;AACA,8E;AACA,uD;AACA,M;AACA,sE;;AAEA,iC;AACA,qE;AACA,0C;AACA,yC;AACA,M;AACA,8B;AACA,sE;AACA,kF;AACA,oE;AACA,iD;AACA,M;AACA,oD;AACA,iC;AACA,yC;AACA,iD;AACA,M;AACA,2C;AACA,2E;AACA,0C;AACA,yC;AACA,M;;AAEA,oF;AACA,mC;AACA,6B;AACA,yE;AACA,M;AACA,gC;AACA,6B;AACA,8E;AACA,M;;AAEA,wF;AACA,yD;;AAEA,8C;AACA,+C;AACA,8D;;AAEA,wD;;AAEA,gC;AACA,8B;AACA,2D;AACA,mD;AACA,+D;AACA,0B;AACA,0B;AACA,M;AACA,mF;;AAEA,wD;AACA,mF;AACA,6C;AACA,wC;AACA,O;AACA,uD;AACA,+E;AACA,O;AACA,sD;AACA,0E;AACA,O;;AAEA,iG;AACA,wD;AACA,6H;AACA,M;AACA,0E;AACA,0E;;AAEA,yD;;AAEA,6B;AACA,8B;AACA,gE;AACA,M;AACA,6D;;AAEA,2B;AACA,oC;AACA,2D;AACA,M;AACA,kE;;AAEA,4B;AACA,wD;AACA,6D;AACA,M;AACA,oC;AACA,8C;AACA,yC;AACA,6C;AACA,M;;AAEA,2C;AACA,sF;AACA,M;AACA,yC;AACA,qG;AACA,iE;AACA,+B;AACA,4D;AACA,M;AACA,gC;AACA,+B;AACA,oE;AACA,yD;AACA,4B;AACA,yD;AACA,mD;AACA,0D;AACA,O;AACA,qB;AACA,M;AACA,6B;AACA,uB;AACA,gC;AACA,mC;AACA,qD;AACA,+D;AACA,S;AACA,qB;AACA,M;;AAEA,iC;AACA,kC;AACA,gC;AACA,sC;AACA,gD;AACA,kB;AACA,iB;AACA,S;AACA,4C;AACA,M;AACA,qC;AACA,qC;AACA,4B;AACA,8D;AACA,0D;AACA,sC;AACA,S;AACA,mB;AACA,M;;AAEA,iC;AACA,yG;AACA,uE;AACA,oG;AACA,wF;AACA,wB;AACA,uD;AACA,0C;AACA,O;AACA,iB;AACA,M;;AAEA,kC;AACA,iC;AACA,yD;AACA,2E;AACA,iE;AACA,0F;AACA,0D;AACA,4F;AACA,kF;AACA,kB;AACA,M;AACA,gC;AACA,yD;AACA,qE;AACA,kC;AACA,wC;AACA,iC;AACA,8B;AACA,c;AACA,O;AACA,uD;AACA,0C;AACA,kC;AACA,wE;AACA,sC;AACA,2E;AACA,+E;AACA,O;AACA,M;AACA,uD;;AAEA,4C;AACA,2C;AACA,K;;AAEA,8C;;AAEA,qE;AACA,oE;AACA,4G;AACA,oD;AACA,oE;AACA,4B;;AAEA,+C;AACA,+C;AACA,mE;AACA,gC;AACA,sC;AACA,kD;AACA,gD;AACA,2B;AACA,wC;AACA,O;AACA,K;AACA,+B;AACA,G;;AAEA,+B;AACA,oE;AACA,iB;AACA,gB;AACA,4B;AACA,iB;AACA,uD;AACA,qC;AACA,kB;AACA,G;;AAEA,mB;;AAEA,8B;AACA,qB;AACA,0B;AACA,6B;AACA,8D;AACA,6C;AACA,gB;AACA,O;AACA,K;AACA,0B;AACA,G;;AAEA,wC;AACA,iC;AACA,uD;AACA,2B;AACA,sD;AACA,uD;AACA,qB;AACA,U;AACA,O;AACA,e;AACA,G;AACA,oC;AACA,iB;AACA,gE;AACA,e;AACA,G;;AAEA,2C;AACA,oC;AACA,yD;AACA,G;;AAEA,yB;AACA,yC;AACA,yD;AACA,4E;AACA,6B;AACA,4C;AACA,4C;AACA,O;AACA,K;AACA,0B;AACA,G;;AAEA,mC;AACA,wB;AACA,e;AACA,8D;AACA,yD;AACA,sD;AACA,gB;AACA,+B;AACA,O;AACA,e;AACA,2B;AACA,yD;AACA,kD;AACA,wB;AACA,c;AACA,K;AACA,iB;AACA,G;;AAEA,sC;AACA,0C;;AAEA,sC;AACA,kD;AACA,gC;AACA,iC;AACA,4B;AACA,K;AACA,gE;AACA,mD;AACA,gC;AACA,gC;AACA,6B;AACA,O;AACA,K;AACA,a;AACA,G;;AAEA,2B;AACA,2B;AACA,oE;AACA,iB;AACA,G;;AAEA,Y;;AAEA,0B;AACA,Y;AACA,mE;AACA,gE;AACA,2D;AACA,gD;AACA,oE;AACA,c;AACA,kD;AACA,qC;AACA,qB;AACA,M;AACA,G;;AAEA,oD;AACA,oD;AACA,4F;AACA,2B;AACA,wF;AACA,U;AACA,O;AACA,G;;AAEA,iD;AACA,+G;AACA,4E;AACA,oH;AACA,sB;AACA,G;;AAEA,sD;AACA,2B;AACA,2B;AACA,+C;;AAEA,c;AACA,+B;AACA,6D;AACA,+G;AACA,8C;AACA,kC;AACA,yE;AACA,mE;AACA,mD;AACA,oC;AACA,c;AACA,4B;AACA,+D;AACA,O;AACA,uE;AACA,Y;AACA,8C;AACA,6D;AACA,oE;AACA,qE;AACA,0B;AACA,+C;AACA,0B;AACA,gC;AACA,8E;AACA,kF;AACA,gC;AACA,U;AACA,4B;AACA,K;AACA,yB;AACA,uB;AACA,oC;AACA,G;;AAEA,sC;AACA,4B;AACA,iD;AACA,mF;AACA,uC;AACA,K;AACA,kD;AACA,G;;AAEA,qC;AACA,0C;AACA,4B;AACA,yD;AACA,4C;AACA,c;AACA,G;;AAEA,sE;AACA,sD;AACA,+C;AACA,wD;AACA,sE;AACA,qG;AACA,8E;AACA,gD;AACA,mC;AACA,+E;AACA,qF;AACA,qD;AACA,iD;AACA,gC;AACA,W;AACA,S;AACA,O;AACA,K;AACA,gB;AACA,G;;AAEA,uE;;AAEA,+C;AACA,wB;AACA,uB;AACA,iC;AACA,sB;AACA,iB;AACA,K;AACA,G;;AAEA,qE;AACA,qE;AACA,sE;AACA,gE;AACA,+D;AACA,sE;AACA,oD;AACA,mD;AACA,4C;AACA,oC;AACA,oD;AACA,iC;AACA,oF;AACA,iC;AACA,gC;AACA,8B;AACA,yC;AACA,qB;AACA,gB;AACA,S;AACA,O;AACA,wB;AACA,+F;AACA,2F;AACA,0B;AACA,O;AACA,gB;AACA,+B;AACA,c;AACA,c;AACA,uE;AACA,qE;AACA,O;AACA,K;AACA,G;;AAEA,qC;AACA,kG;AACA,+C;AACA,iD;AACA,G;;AAEA,oB;;AAEA,uC;AACA,uC;AACA,2B;AACA,6C;AACA,iB;AACA,G;;AAEA,gC;AACA,6C;AACA,+B;AACA,G;AACA,iC;AACA,+C;AACA,+B;AACA,G;AACA,iE;AACA,6B;AACA,iD;AACA,mD;;AAEA,yD;AACA,wB;AACA,oB;AACA,oB;AACA,8B;AACA,mC;AACA,mC;AACA,K;AACA,0C;AACA,a;AACA,G;;AAEA,mB;;AAEA,iC;AACA,iC;AACA,+C;AACA,iC;AACA,0C;AACA,U;AACA,8D;AACA,8C;AACA,kB;AACA,K;AACA,G;;AAEA,kC;AACA,oC;AACA,kD;AACA,iC;AACA,0C;AACA,U;AACA,6D;AACA,uB;AACA,0C;AACA,qD;AACA,K;AACA,G;;AAEA,kD;AACA,2D;AACA,qB;AACA,wD;AACA,kE;AACA,G;;AAEA,iD;AACA,uD;AACA,2D;AACA,qB;AACA,wD;AACA,4B;AACA,6B;AACA,4B;AACA,iC;AACA,K;AACA,+D;AACA,wC;AACA,yC;AACA,G;;AAEA,0B;AACA,2B;AACA,mC;AACA,4B;AACA,0D;AACA,G;;AAEA,sC;AACA,2D;AACA,iC;AACA,G;;AAEA,uE;;AAEA,mB;;AAEA,mE;AACA,0B;;AAEA,+D;AACA,oB;AACA,iF;;AAEA,sC;AACA,mG;;AAEA,oE;AACA,qC;AACA,sE;AACA,sB;AACA,yC;AACA,yC;AACA,K;AACA,sE;AACA,iE;AACA,e;AACA,K;AACA,a;AACA,G;AACA,uC;;AAEA,uB;AACA,wB;AACA,iC;AACA,2C;AACA,wB;AACA,G;;AAEA,iD;;AAEA,8B;AACA,8E;AACA,8B;AACA,4C;AACA,yB;AACA,G;;AAEA,qC;AACA,2D;AACA,sD;AACA,yC;AACA,c;AACA,G;;AAEA,mC;AACA,qB;AACA,yB;AACA,yB;AACA,oC;AACA,gB;AACA,G;;AAEA,iC;AACA,6B;AACA,iF;AACA,kB;AACA,G;;AAEA,6B;AACA,6D;AACA,a;AACA,G;;AAEA,oB;AACA,wD;AACA,mD;AACA,G;;AAEA,4F;AACA,2B;AACA,0C;AACA,oF;AACA,G;;AAEA,yB;AACA,yE;AACA,gB;AACA,G;;AAEA,8P;;AAEA,kB;;AAEA,gD;AACA,wC;AACA,2C;AACA,uC;AACA,+D;AACA,yF;AACA,a;AACA,G;;AAEA,8B;AACA,kF;AACA,8B;AACA,0D;AACA,a;AACA,G;;AAEA,4C;AACA,iD;AACA,G;;AAEA,mC;AACA,iB;AACA,uB;AACA,kD;AACA,+B;AACA,G;;AAEA,0B;AACA,wC;AACA,G;AACA,2D;;AAEA,sB;;AAEA,yB;AACA,gC;AACA,oE;AACA,mC;AACA,6B;AACA,yB;AACA,mD;AACA,M;;AAEA,kE;AACA,oE;AACA,oE;AACA,qE;AACA,iE;AACA,mE;AACA,sB;AACA,yE;AACA,wC;AACA,wI;AACA,6G;;AAEA,0B;AACA,oC;AACA,gE;AACA,uF;AACA,wC;AACA,yB;AACA,kE;AACA,oC;AACA,G;;AAEA,oB;AACA,sC;AACA,gC;AACA,uC;AACA,uF;AACA,+C;AACA,kF;AACA,K;AACA,oD;AACA,qG;AACA,G;;AAEA,gE;AACA,oC;AACA,uE;AACA,gD;AACA,sB;AACA,yC;AACA,uC;AACA,gF;AACA,kC;AACA,qB;AACA,uC;AACA,sB;AACA,c;AACA,0B;AACA,qB;AACA,O;AACA,K;AACA,kB;AACA,yD;AACA,qC;;AAEA,yD;AACA,wD;AACA,8B;AACA,oB;AACA,+D;AACA,e;AACA,4D;AACA,4D;AACA,I;;AAEA,kC;AACA,uB;AACA,mC;AACA,wC;AACA,yC;AACA,O;;AAEA,e;;AAEA,wG;AACA,+G;AACA,2G;AACA,4G;AACA,4G;AACA,sG;AACA,+G;AACA,iC;AACA,e;AACA,kB;AACA,8D;AACA,sB;AACA,wE;AACA,oB;AACA,oF;AACA,O;;AAEA,iB;;AAEA,oD;AACA,0C;AACA,4C;AACA,0B;AACA,4E;AACA,6F;AACA,K;AACA,G;;AAEA,0E;AACA,2E;;AAEA,gG;AACA,4B;AACA,+B;AACA,wC;AACA,iC;AACA,G;;AAEA,iC;AACA,sC;AACA,0C;AACA,+C;AACA,iC;AACA,oF;AACA,0B;AACA,G;AACA,+B;AACA,qB;AACA,sE;AACA,oC;AACA,+B;AACA,+F;AACA,0B;AACA,G;;AAEA,6D;AACA,kE;AACA,+D;AACA,kE;AACA,mE;AACA,kD;AACA,mD;AACA,8B;AACA,8D;AACA,mD;AACA,oB;AACA,qE;AACA,iB;AACA,iD;AACA,gC;AACA,2C;AACA,6D;AACA,mD;AACA,sE;AACA,K;AACA,iE;;AAEA,4B;AACA,sC;AACA,qD;AACA,gC;AACA,8G;AACA,qB;AACA,c;AACA,uC;AACA,2B;AACA,2C;AACA,+C;AACA,2B;AACA,0C;AACA,qB;AACA,O;AACA,K;;AAEA,mE;AACA,G;;AAEA,oD;AACA,6B;AACA,mG;AACA,mE;AACA,G;;AAEA,qC;AACA,qE;AACA,sC;;AAEA,6C;AACA,2B;AACA,2B;AACA,kC;AACA,6B;AACA,uC;AACA,wC;AACA,2B;AACA,qC;AACA,8B;AACA,8B;AACA,iC;AACA,+B;AACA,wB;AACA,4B;;AAEA,0D;AACA,gE;AACA,wD;AACA,kC;AACA,+C;AACA,sR;AACA,oD;AACA,yR;AACA,6B;AACA,qD;AACA,0D;AACA,uF;AACA,0D;AACA,sB;AACA,K;;AAEA,6D;AACA,gG;AACA,iF;AACA,wB;;AAEA,0B;AACA,0C;AACA,uC;AACA,yC;AACA,uD;;AAEA,sE;AACA,+D;AACA,wE;AACA,6B;AACA,uD;AACA,4B;AACA,yC;AACA,yB;AACA,O;;AAEA,qE;AACA,uE;AACA,sE;AACA,gB;AACA,iC;AACA,sD;AACA,4B;AACA,sD;AACA,sF;AACA,O;;AAEA,qE;AACA,wE;AACA,2D;AACA,0D;AACA,4B;AACA,4E;AACA,qD;AACA,+D;AACA,oB;AACA,O;;AAEA,oE;AACA,iD;AACA,kE;AACA,iB;AACA,qC;AACA,4B;AACA,wC;AACA,+B;AACA,yE;AACA,qG;AACA,2D;AACA,sB;AACA,S;AACA,O;;AAEA,qE;AACA,wE;AACA,iE;AACA,sD;AACA,4B;AACA,sD;AACA,iD;AACA,O;;AAEA,8D;AACA,uE;AACA,wE;AACA,uE;AACA,qE;AACA,iE;AACA,qC;AACA,uC;AACA,kF;AACA,2D;AACA,sE;AACA,oD;AACA,2D;AACA,sB;AACA,S;AACA,O;;AAEA,wE;AACA,uE;AACA,gE;AACA,sE;AACA,8D;AACA,wB;AACA,iC;AACA,0C;AACA,wB;AACA,mE;AACA,qD;AACA,gB;AACA,yC;AACA,uD;AACA,qC;AACA,6C;AACA,6E;AACA,6B;AACA,oE;AACA,mE;AACA,sB;AACA,uB;AACA,W;AACA,yE;AACA,S;AACA,O;AACA,2D;AACA,oC;AACA,4D;AACA,O;AACA,6D;AACA,qC;AACA,iE;AACA,O;AACA,6C;AACA,gE;;AAEA,mB;AACA,M;AACA,O;;AAEA,Y;;AAEA,+B;;AAEA,oB;AACA,K;;;;;;;;;;;;;;;;;;;AC9zKA,0D;;AAEA,oE;AACA,qC;AACA,mC;AACA,qC;;AAEA,c;;AAEA,4B;AACA,8D;AACA,sE;AACA,wE;AACA,I;AACA,sB;AACA,iF;AACA,gF;AACA,6D;AACA,uD;AACA,6F;AACA,iE;AACA,kG;AACA,wB;AACA,M;;AAEA,2E;AACA,e;AACA,yD;AACA,wB;AACA,6B;AACA,qC;AACA,6B;AACA,iC;AACA,yC;;AAEA,0B;AACA,+B;AACA,iC;AACA,qC;AACA,+B;;AAEA,6B;;AAEA,gB;AACA,iE;AACA,Q;;AAEA,oC;AACA,4C;AACA,O;AACA,K;;AAEA,sB;AACA,M;;AAEA,0C;;AAEA,oC;AACA,uB;AACA,4B;AACA,G;;AAEA,4C;AACA,8B;AACA,4C;AACA,kC;AACA,qB;AACA,yC;AACA,K;AACA,mB;AACA,G;;AAEA,qE;AACA,gC;AACA,oB;AACA,iC;AACA,8B;AACA,iB;AACA,G;;AAEA,uC;AACA,2B;AACA,+B;AACA,qD;AACA,2C;AACA,qB;AACA,6C;AACA,kC;AACA,qC;AACA,W;AACA,8D;AACA,uD;AACA,qC;AACA,K;AACA,yB;AACA,4B;AACA,oD;AACA,O;AACA,iC;AACA,2B;AACA,yC;AACA,O;AACA,+E;AACA,sD;AACA,wC;AACA,uE;AACA,yC;AACA,O;AACA,Y;AACA,wC;AACA,uD;AACA,O;AACA,K;AACA,yB;AACA,yB;AACA,mC;AACA,K;AACA,uC;AACA,sC;AACA,qD;AACA,K;AACA,U;AACA,iC;AACA,iG;AACA,oF;AACA,uD;AACA,K;AACA,G;;AAEA,iC;AACA,oC;AACA,6C;AACA,qC;AACA,qC;AACA,M;AACA,G;;AAEA,0C;AACA,6B;AACA,gC;AACA,kC;AACA,qC;AACA,c;AACA,O;AACA,6B;AACA,K;AACA,qC;AACA,G;;AAEA,W;;AAEA,mH;;AAEA,iE;AACA,6B;AACA,yB;AACA,qB;AACA,qB;AACA,qB;AACA,0C;AACA,G;;AAEA,oC;AACA,gD;AACA,yC;AACA,G;;AAEA,yD;AACA,sB;AACA,kD;AACA,wE;AACA,uE;AACA,E;AACA,+C;AACA,iC;;AAEA,iB;AACA,gF;AACA,sC;AACA,iD;AACA,qB;AACA,wC;AACA,+E;AACA,qB;AACA,O;AACA,K;AACA,G;;AAEA,qB;;AAEA,+D;AACA,mB;AACA,6E;AACA,G;AACA,mB;AACA,gC;AACA,gB;AACA,G;AACA,8B;AACA,2B;AACA,uC;AACA,2C;AACA,mB;AACA,K;AACA,yB;AACA,wB;AACA,wB;AACA,0C;AACA,+D;AACA,Y;AACA,2C;AACA,iE;AACA,K;AACA,G;;AAEA,gB;;AAEA,8D;AACA,0B;AACA,0E;AACA,qC;AACA,G;AACA,yB;AACA,+C;AACA,6C;AACA,G;AACA,gC;AACA,6B;AACA,2B;AACA,yG;AACA,M;AACA,sB;AACA,kB;AACA,G;AACA,qB;AACA,yB;AACA,6B;AACA,oC;AACA,gD;AACA,yC;AACA,K;AACA,G;AACA,oB;;AAEA,2B;AACA,2B;AACA,wC;AACA,4C;AACA,yC;AACA,M;AACA,G;;AAEA,4B;AACA,oF;AACA,yF;AACA,6E;AACA,8D;AACA,mC;AACA,qD;AACA,qG;AACA,iE;AACA,qE;AACA,uG;AACA,gE;AACA,6D;AACA,oD;AACA,oG;AACA,uE;AACA,kE;AACA,G;AACA,6B;AACA,qE;AACA,qD;AACA,0D;AACA,oG;AACA,oD;AACA,iG;AACA,8F;AACA,kB;AACA,G;AACA,kC;AACA,gD;AACA,4B;AACA,G;AACA,I;AACA,uC;AACA,6B;AACA,4D;AACA,yE;AACA,8B;AACA,K;AACA,4B;AACA,iG;AACA,0D;AACA,+F;AACA,G;AACA,6B;AACA,oD;AACA,oD;AACA,G;AACA,2B;AACA,oE;AACA,G;AACA,0B;AACA,mD;AACA,kF;AACA,+E;AACA,G;AACA,gC;AACA,4B;AACA,kD;AACA,qC;AACA,+B;AACA,K;AACA,2B;AACA,qC;AACA,sC;AACA,M;AACA,G;AACA,wB;AACA,mC;AACA,kC;AACA,G;AACA,4B;AACA,0C;AACA,kB;AACA,G;AACA,0B;AACA,qE;AACA,kB;AACA,G;AACA,iC;AACA,6B;AACA,sB;AACA,6D;AACA,K;AACA,kB;AACA,G;AACA,iC;AACA,uD;AACA,0C;AACA,G;AACA,2B;AACA,mE;AACA,2C;AACA,oD;AACA,0B;AACA,G;AACA,qC;AACA,+C;AACA,yC;AACA,G;AACA,kC;AACA,2C;AACA,+C;AACA,mD;AACA,G;AACA,2B;AACA,sC;AACA,G;AACA,qC;AACA,wE;AACA,kH;AACA,G;AACA,gC;AACA,sF;AACA,G;;AAEA,c;;AAEA,U;AACA,sC;AACA,c;AACA,8B;AACA,uB;AACA,e;AACA,kF;AACA,0C;AACA,4C;AACA,0E;AACA,mB;AACA,Q;AACA,M;;AAEA,oC;AACA,yB;AACA,mD;AACA,sC;AACA,8C;AACA,O;AACA,yC;AACA,gD;AACA,0C;AACA,4B;AACA,0D;AACA,M;;AAEA,wC;AACA,mE;AACA,kD;AACA,gF;AACA,6E;AACA,2D;AACA,sH;AACA,2E;AACA,oE;AACA,8B;AACA,2G;AACA,oD;AACA,wG;AACA,wE;AACA,gE;AACA,M;;AAEA,yB;;AAEA,sB;AACA,I;AACA,G;;AAEA,uD;AACA,uD;AACA,8D;AACA,8D;AACA,4E;AACA,mF;AACA,0F;;;;;;;;;;;;;;;;;;;AC1aA,G;AACA,qC;AACA,4D;AACA,G;AACA,sD;AACA,6B;;AAEA,gC;AACA,+D;AACA,K;;AAEA,kE;AACA,uE;AACA,uK;AACA,uG;AACA,oF;AACA,8D;AACA,uE;;AAEA,uD;AACA,uD;AACA,6D;AACA,yE;AACA,wE;AACA,0E;AACA,oE;AACA,4D;;AAEA,qE;;AAEA,gD;;;AAGA,2D;AACA,gD;AACA,8G;AACA,gD;;AAEA,iB;AACA,uC;AACA,+B;AACA,2B;AACA,qD;AACA,oC;AACA,sD;AACA,+C;AACA,oC;AACA,sD;AACA,oC;AACA,iB;AACA,4B;AACA,oB;AACA,sC;AACA,0C;AACA,iB;AACA,a;AACA,S;AACA,gC;AACA,wB;AACA,S;;AAEA,+B;;AAEA,mD;AACA,mC;AACA,+B;AACA,6B;AACA,S;;AAEA,qC;AACA,kC;AACA,yC;AACA,iD;AACA,S;;AAEA,8B;AACA,yB;AACA,+B;AACA,6B;AACA,S;;AAEA,iC;AACA,gD;AACA,qC;AACA,qB;AACA,6D;AACA,kC;AACA,a;AACA,8C;AACA,kC;AACA,a;AACA,2C;AACA,kC;AACA,a;;AAEA,+B;AACA,sD;AACA,0C;AACA,qC;AACA,iB;AACA,gC;AACA,a;AACA,uB;AACA,mC;AACA,kB;AACA,kD;AACA,gC;AACA,a;AACA,sB;AACA,4D;AACA,kC;AACA,a;AACA,4D;AACA,iD;AACA,gC;AACA,a;AACA,6B;AACA,gC;AACA,a;AACA,S;;AAEA,yB;AACA,2C;AACA,sE;AACA,iD;AACA,S;AACA,gC;AACA,0C;AACA,2G;AACA,4E;AACA,qD;AACA,oB;AACA,iC;AACA,a;AACA,S;;AAEA,0C;AACA,+E;AACA,iC;AACA,S;AACA,yC;AACA,4C;AACA,6C;AACA,8B;AACA,S;AACA,6C;AACA,iC;AACA,S;;AAEA,sC;AACA,0B;AACA,S;;AAEA,qC;AACA,6B;AACA,S;;AAEA,wC;AACA,8B;AACA,S;;AAEA,uC;AACA,8B;AACA,S;;AAEA,oC;AACA,sB;AACA,0B;AACA,K;;AAEA,gD;AACA,+C;AACA,wC;AACA,mC;AACA,6C;AACA,uC;AACA,kC;AACA,qD;AACA,wC;AACA,qB;AACA,qD;AACA,+C;AACA,oC;AACA,wB;AACA,yC;AACA,iB;AACA,a;AACA,6B;AACA,uD;AACA,0C;AACA,wB;AACA,+C;AACA,iB;AACA,a;AACA,4B;AACA,U;AACA,K;;AAEA,yC;AACA,+B;AACA,oC;AACA,sC;AACA,2C;AACA,sB;AACA,a;AACA,iC;AACA,S;AACA,yB;AACA,K;;AAEA,0C;AACA,gC;AACA,2B;AACA,gC;AACA,2D;AACA,wD;AACA,0E;AACA,0B;AACA,iB;AACA,a;AACA,gB;AACA,mE;AACA,S;AACA,8B;AACA,+B;AACA,sB;AACA,W;AACA,K;;AAEA,oC;AACA,6C;AACA,gD;AACA,+C;AACA,mC;AACA,2D;AACA,yD;AACA,sC;AACA,0B;AACA,iB;AACA,a;AACA,uC;AACA,4B;AACA,a;AACA,wD;AACA,qC;AACA,a;AACA,yB;AACA,gB;AACA,iC;AACA,yB;AACA,S;AACA,K;;AAEA,wC;AACA,kD;AACA,uC;;AAEA,2C;AACA,8B;AACA,kD;AACA,uC;AACA,6C;AACA,kC;AACA,oB;AACA,kC;AACA,a;AACA,S;;AAEA,gC;AACA,mC;AACA,8B;AACA,S;AACA,sD;AACA,kC;AACA,qD;AACA,uC;AACA,uC;AACA,kC;AACA,S;AACA,qD;AACA,qC;AACA,mF;AACA,S;AACA,0C;AACA,kC;AACA,S;AACA,+B;AACA,kC;AACA,S;;;AAGA,iC;AACA,wC;AACA,kC;AACA,a;AACA,S;AACA,iD;AACA,qC;AACA,wC;AACA,kC;AACA,a;AACA,S;AACA,mF;AACA,8D;AACA,8B;AACA,S;;AAEA,qB;AACA,K;;AAEA,oB;AACA,0C;AACA,oB;AACA,kC;AACA,gE;AACA,8B;AACA,4B;AACA,uB;AACA,Y;AACA,U;;AAEA,wC;AACA,kD;;AAEA,uE;;AAEA,gD;AACA,qC;AACA,a;;AAEA,yB;AACA,U;;AAEA,iC;AACA,8C;AACA,yB;AACA,a;;AAEA,0C;AACA,U;;AAEA,yB;AACA,sB;AACA,M;AACA,oB;AACA,G;;AAEA,6D;;;;;;;;;;;;;;;;;;;AC3VA,29F;AACA,4vE;AACA,gmF;AACA,m5B;AACA,0tE;AACA,mL;;;;;;;;;;;;;;;;;;;;ACLA;;GAAQ,CAAI,CAAZ,IAAQ;;AAER,CAFA,EAEe,GAAT,CAAN,EAAe;CACF,CAA+B,OAA1C,CAAU,IAAV;CACU,EAAR,IAAO,IAAP;CADF,EAA0C;CAD7B;;AAUf,CAZA,KAYA,EAAQ,MAAe;CAErB,EAAsB,MAAC,WAAvB;CACE;GAAK,CAAL,EAAe,MAAV;CAEL;CAAQ,CAAmC,CAA3C,IAAO,MAAP;KAHoB;CAAtB,EAAsB;CAAtB,CAOA,CAA8B,yBAA9B;CACE,EAAG,CAAH,CAAsC,EAA5B,QAAV,GAAG;CACD,CAAgC,CAAhC,IAAO,SAAP;CACQ,CAAmC,CAA3C,IAAO,IAAP;MAFF;CAIE,CAAgC,CAAhC,IAAO,QAAP;CACQ,CAAmC,CAA3C,IAAO,GAAP;KAN0B;CAP9B,EAO8B;CAP9B,CAiBA,CAA4B,uBAA5B;CAEO,GAAD,EAAJ;CAnBF,EAiB4B;CAjB5B,CAqBA,CAA6B,wBAA7B;CACE;GAAI,CAAJ,GAAW,mBAAP;CACJ,WAAO;CAAP,UACO,GADP;CAEY,CAAgC,CAAxC,IAAO,KAAP;CAFJ,UAGO,CAHP;CAIY,CAAgC,CAAxC,IAAO,KAAP;CAJJ,UAKO,CALP;CAMY,CAAgC,CAAxC,IAAO,OAAP;CANJ,IAF2B;CArB7B,EAqB6B;CArB7B,CAiCA,CAA0B,MAAC,eAA3B;CACW,OAAD,EAAR,IAAuB;CAlCzB,EAiC0B;CA/C5B,CAYA;;AA0CA,CAtDA,MAsDA,CAAQ,MAAe;CACrB,EAA4B,uBAA5B;CACE;GAAO,CAAP,GAAc,sBAAP;CACP,OAAY;CACK,GAAX,IAA+B,EAArB,GAAV;MADN;CAGiB,GAAX,IAA+B,EAArB,GAAV,SAA+B;KALX;CAA5B,EAA4B;CAA5B,CAOA,CAAU,KAAV,CAAU;AACA,CAAR,EAAS,IAAO,IAAT,IAAE;CARX,EAOU;CAPV,CAUA,CAAW,MAAX;CACE,EAAO,IAAO,IAAP;CAXT,EAUW;CAVX,CAaA,CAAc,SAAd;CACU,EAAR,IAAO,IAAP;CAdF,EAac;CAbd,CAiBA,CAAO,EAAP,IAAO;CACG,EAAR,IAAO,IAAP;CAlBF,EAiBO;CAjBP,CAsBA,CAAQ,GAAR,GAAQ;CACE,EAAR,IAAO,IAAP;CAvBF,EAsBQ;CA7EV,CAsDA;;AA+BA,CArFA,CAsFE,IADF,EAAiB,MAAjB;CACE,EAAY,OAAZ;CACE;GAAO,IAAO,KAAP;CAAP,UACO;CACH,CAA6B,CAA7B,IAAO,CAAP;EACoC,CAApC,IAAO,CAAP;CADA,CAEqC,CAArC,IAAO,CAAP;CAHG;CADP,UAMO;CACH,CAAoC,CAApC,IAAO,CAAP;IACA;CADA,CAE6B,CAA7B,IAAO,CAAP;CAHG;CANP,UAWO;CACH,CAAoC,CAApC,IAAO,CAAP;EACqC,CAArC,IAAO,CAAP;CAFG;CAXP,UAcO;CACH,CAA6B,CAA7B,IAAO,CAAP;EACoC,CAApC,IAAO,CAAP;CADA,CAEqC,CAArC,IAAO,CAAP;CAFA,CAG6B,CAA7B,IAAO,CAAP;CAHA,OAIA;CAJA,GAKA;CApBJ;IAyBA;CAEA,CAAmC,EAAnC,EAAG,CAAO,QAAP;CACD,EAAK,GAAL,KAAK;CAEL,CAAiD,CAAjD;MAHF;CAKE,CAAiD,CAAjD;KAjCQ;CAAZ,EAAY;CAAZ,CAqCA,CAAW,MAAX;CArCA,CAyCA,CAAS,IAAT,EAAS;CAGP;OAAa,WAAP;CACN;CAAa,OAAQ,EAAR,IAAuB;MAApC;CAAyD,OAAQ,EAAR,IAAuB;KADhF;EAEkD,EAAlD,GAAO,GAAP;CAFA,CAG+C,EAA/C,GAAO,GAAP;CAIK,EAAQ,CAAT,GAAJ,EAAa,EAAb;CAEU,CAAsC,CAA9C,GAAoD,CAA7C,MAAP;CAFF,IAAa;CAnDf,EAyCS;CAzCT,CAyDA,CAAU,KAAV,CAAU;CAER,CAAkD,EAAlD,GAAO,GAAP;CAEA,EAAwB,GAAxB;CAEE;GAAG,GAAH;AAE4B,CAA5B,CAA4B,CAAtB,CAAH,EAAH,CAA4B;CAC1B,EAAM,CAAH,GAAH;CACW,OAAD,EAAR,IAAuB,GAAvB;MADF;CAGE,EAAI,IAAO,GAAX,gBAAI;CACJ,iBAAO;CAAP,gBACO;CACK,CAAgC,CAAxC,IAAO,KAAP;CAFJ,gBAGO;CACK,CAAgC,CAAxC,IAAO,KAAP;CAJJ,gBAKO;CACK,CAAgC,CAAxC,IAAO,OAAP;CANJ,UAJF;SADF;OAJsB;CAAxB,IAAwB;CA7D1B,EAyDU;CAzDV,CAoFA,CAAY,MAAC,CAAb;CACE,WAAO;CAAP,UACO;CACH,CAAmC,EAAnC,GAAO,CAAP;EACgC,KAAzB,CAAP;CADA,CAE4C,GAA5C,EAAO,CAAP;CAFA,CAG2C,KAApC,CAAP;CAHA,CAIuC,KAAhC,CAAP;CAJA,CAKoC,GAApC,EAAO,CAAP;CACQ,CAA4B,GAApC,EAAO,GAAP;CARJ,UASO;CACH,CAAmC,EAAnC,GAAO,CAAP;EACgC,KAAzB,CAAP;CADA,CAE4C,GAA5C,EAAO,CAAP;CAFA,CAG2C,KAApC,CAAP;CAHA,CAIuC,KAAhC,CAAP;CAJA,CAKoC,EAApC,GAAO,CAAP;CACQ,CAA4B,EAApC,GAAO,GAAP;CAhBJ,IADU;CApFZ,EAoFY;CA1Kd,CAqFA;;AA8GA,CAnMA,KAmMA,EAAQ,iBAA0B;CAChC,EAAuC,MAAC,4BAAxC;CACE;GAAU,CAAV,EAA6B,CAA7B,CAAmB;CACnB;;KADA;GAES,CAAT,QAAS;CAFT,GAGA,CAAmC;CACnC;CACE,EAAS,GAAT;AACA;;;CACE,EAAI,KAAJ;WACA;CAFF;sBAFF;KALqC;CAAvC,EAAuC;CAAvC,CAYA,CAAuC,MAAC,4BAAxC;CACE;GAAU,CAAV,EAA6B,CAA7B,CAAmB;CACnB;;KADA;GAES,CAAT,QAAS;CAET,IAAc,CAAX,KAAH;CACE,EAAO,CAAP,GAAe;CAAf,EACU,CADV,CACU,CAAV,MAA2B,EAAjB;MAFZ;CAKE;CACA,GAAG,EAAH;CACE,EAAU,CAAV,CAAU,EAAV,KAAU;CAAV,EAES,GAAT;AACA;;CACE,EAAI,OAAJ;QACA;CAFF,QAJF;;CAQE,IAAmC,GAAnC;GACU,CADV,CACU,EAAV,MAAU;OAfd;KAJA;CAuBM,IAAD,EAAL,KAAkB;CApCpB,EAYuC;CAZvC,CA2CA,CAA4B,MAAC,iBAA7B;CACE,EAAiB,CAAjB,CAAK,CAAO;CACJ,CAAiC,CAAzC,GAAyC,CAAlC,IAAP;CA7CF,EA2C4B;CA/O9B,CAmMA;;AAqDA,CAxPA,MAwPA,CAAQ,iBAA0B;CAChC,EAAsB,iBAAtB;CACU,EAAR,IAAO,IAAP;CADF,EAAsB;CAAtB,CAIA,CAAW,MAAX;CACE;GAAK,CAAL,GAAY,CAAP;CAAL,CACE,EAAF;CAFS,UAGT;CAPF,EAIW;CAJX,CASA,CAAuB,kBAAvB;CACW,CAAgD,KAAO,CAAxD,GAAR,cAAkC,EAAuB;CAV3D,EASuB;CATvB,CAYA,CAAwB,mBAAxB;CACW,CAAiD,KAAO,CAAzD,CAAR,gBAAkC,EAAwB;CAb5D,EAYwB;CArQ1B,CAwPA;;AAqBA,CA7QA,CA8QE,IADF,EAAiB,iBAAjB;CACE,EAAW,MAAX;EAGA,CAAS,IAAT,EAAS;CAMP;;;;;;;AANO;CAHT,EAGS;CAHT,CAiBA,CAAU,KAAV,CAAU;CACR,MAAkC,YAAlC,QAA2B;CAA3B,CACyC,CAAzC,IAAO,YAAkC,QAAzC;CADA,EAIgB,CAAhB;CACA;CACG,CACC,CADc,CAAf,IAAkC,EAAnB,EAAhB,EAA2B;CACzB,CAAO,GAAP;EACO,EAAP,QADA;EAEO,GAAP,EAAc,CAAd,qBAAO;CAFP,CAGU,EAHV,IAGA;CALJ,OACkB;KAPV;CAjBV,EAiBU;CAjBV,CA+BA,CAAc,MAAC,GAAf;CACE;GAAK,CAAL;AACA;EAAE,EAAF;KADA;CAEG,CAAD,EAAF;CAlCF,EA+Bc;CA7ShB,CA6QA;;AA0CA,CAvTA,MAuTA,CAAQ,YAAqB;CAC3B,EAAc,SAAd;CACU,EAAR,IAAO,IAAP;CADF,EAAc;CAAd,CAGA,CAAO,EAAP,IAAO;CACG,EAAR,IAAO,IAAP;CAJF,EAGO;CAHP,CAMA,CAAc,SAAd;CACE;GAAK,CAAL;AACA;EAAE,EAAF;CAAQ,CAAQ,CAAR,EAAC;CAAD,CAAsB,CAAe,CAAX,GAAb,EAAS;CAA9B;KADA;CAEG,CAAD,EAAF;CATF,EAMc;CA9ThB,CAuTA;;AAkBA,CAzUA,KAyUA,EAAQ,YAAqB;CAG3B,EAAwB,mBAAxB;CAEE;EAAyB,CAAzB,IAAO,IAAP;GACY,CAAZ,GAAmB,EAAnB,KAAY;CACZ;CAA0B,CAAmB,CAA3B,IAAO,MAAP;MAAlB;CAAiE,CAAmB,CAA3B,IAAO,MAAP;KAJnC;CAAxB,EAAwB;CAAxB,CAMA,CAAqB,gBAArB;CAEE;EAAyB,CAAzB,IAAO,CAAP;GACY,CAAZ,GAAmB,EAAnB,KAAY;CACZ;CAA0B,CAAmB,CAA3B,IAAO,MAAP;MAAlB;CAAiE,CAAmB,CAA3B,IAAO,MAAP;KAJtC;CANrB,EAMqB;CANrB,CAYA,CAAuB,kBAAvB;CAEE;EAAyB,CAAzB,IAAO,GAAP;GACY,CAAZ,GAAmB,EAAnB,KAAY;CACZ;CAA0B,CAAmB,CAA3B,IAAO,MAAP;MAAlB;CAAiE,CAAmB,CAA3B,IAAO,MAAP;KAJpC;CAZvB,EAYuB;CAZvB,CAkBA,CAAqB,gBAArB;CAEE;EAAyB,CAAzB,IAAO,CAAP;GACY,CAAZ,GAAmB,EAAnB,KAAY;CACZ;CAA0B,CAAmB,CAA3B,IAAO,MAAP;MAAlB;CAAiE,CAAmB,CAA3B,IAAO,MAAP;KAJtC;CAlBrB,EAkBqB;CA9VvB,CAyUA;;AA+BA,CAxWA,MAwWA,CAAQ,YAAqB;CAE3B,EAAc,SAAd;CACE;AAAkD,CAAlD,EAAgB,CAAhB,GAAuB,GAAvB,IAAgB;CAAhB,EACO,CAAP;CAAO,CAAY,IAAX,IAAD;CADP;CAEA,EAAO,IAAO,KAAP;CAAP,UACO;CAAgB,EAAO,CAAP;CAAO,CAAW,MAAV;CAD/B,SACuB;CAAhB;CADP,UAEO;CAAc,EAAO,CAAP;CAAO,CAAW,MAAV;CAF7B,SAEqB;CAAd;CAFP,UAGO;CAAc,EAAO,CAAP;CAAO,CAAS,IAAR;CAH7B,SAGqB;CAHrB,IAFA;CAMK,GAAD,IAAJ;CAPF,EAAc;CAAd,CAUA,CAAgB,MAAC,KAAjB;CACS,GAAD,OAAJ,GAAoB;CAXxB,EAUgB;CAVhB,CAcA,CAAkB,MAAC,OAAnB;CAGE;EAAQ,EAAR;CACY,EAAiC,QAA7C,GAA0B;CAlB5B,EAckB;CAdlB,CAoBA,CAAS,IAAT,EAAU;CACR;;GACO,CAAP;CACA;CACE,EAAI,EAAY,CAAhB,CAAI;CACJ,GAAG,EAAH;CACE,EAAO,CAAP;MADF;CAGE,GAAG,IAAH;CACE,EAAO,CAAP,EAAgB,CAAhB;MADF;CAGE,EAAO,CAAP;SANJ;OAFF;CASY,CATZ,CASW,CAAH,EATR;CASoB,EAAO,CAAP;KAXpB;CADO,UAaP;CAjCF,EAoBS;CApBT,CAqCA,CAAwB,mBAAxB;CACE;IAAQ,IAAR,IAAO;CAAP,GACW,OAAJ,GADP;EACgC,CAAK,YAAL;CADhC,GAEW,OAAJ,GAFP;EAEgC,CAAK,YAAL;CAFhC,GAGW,OAAJ,KAHP;EAGkC,CAAK,YAAL;CAHlC,GAIW,OAAJ,EAJP;EAI+B,CAAK,YAAL;CAJ/B,GAKW,OAAJ,GALP;EAKgC,CAAK,YAAL;CALhC,GAMW,OAAJ,KANP;EAMkC,CAAK,YAAL;CANlC,IADsB;CArCxB,EAqCwB;CArCxB,CAgDA,CAA4B,uBAA5B;CACE;IAAQ,IAAR,IAAO;CAAP,GACW,OAAJ,GADP;EACgC,CAAK,YAAL;CADhC,GAEW,OAAJ,GAFP;EAEgC,CAAK,YAAL;CAFhC,GAGW,OAAJ,KAHP;EAGkC,CAAK,YAAL;CAHlC,IAD0B;CAhD5B,EAgD4B;CAhD5B,CAuDA,CAA4B,uBAA5B;CAGE;IAAQ,IAAR,IAAO;CAAP,GACW,OAAJ,GADP;EACgC,CAAK,YAAL;CADhC,GAEW,OAAJ,GAFP;EAEgC,CAAK,YAAL;CAFhC,GAGW,OAAJ,KAHP;EAGkC,CAAK,YAAL;CAHlC,IAH0B;CAvD5B,EAuD4B;CAja9B,CAwWA;;AAkEA,CA1aA,CA2aE,IADF,EAAiB,eAAjB;CACE,EAAc,SAAd;CACO,GAAD,IAAJ;CADF,EAAc;CA3ahB,CA0aA;A","sourcesContent":["// CodeMirror is the only global var we claim\nwindow.CodeMirror = (function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Crude, but necessary to handle a number of hard-to-feature-detect\n  // bugs and behavior differences.\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  var ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);\n  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /windows/i.test(navigator.platform);\n\n  var opera_version = opera && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (opera_version) opera_version = Number(opera_version[1]);\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));\n  var captureMiddleClick = gecko || (ie && !ie_lt9);\n\n  // Optimize some code when these features are not used\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // CONSTRUCTOR\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options || {};\n    // Determine effective options based on given values and defaults.\n    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))\n      options[opt] = defaults[opt];\n    setGuttersForLineNumbers(options);\n\n    var docStart = typeof options.value == \"string\" ? 0 : options.value.first;\n    var display = this.display = makeDisplay(place, docStart);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.state = {keyMaps: [],\n                  overlays: [],\n                  modeGen: 0,\n                  overwrite: false, focused: false,\n                  suppressEdits: false, pasteIncoming: false,\n                  draggingText: false,\n                  highlight: new Delayed()};\n\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(options.value, options.mode);\n    operation(this, attachDoc)(this, doc);\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie) setTimeout(bind(resetInput, this, true), 20);\n\n    registerEventHandlers(this);\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }\n    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);\n    else onBlur(this);\n\n    operation(this, function() {\n      for (var opt in optionHandlers)\n        if (optionHandlers.propertyIsEnumerable(opt))\n          optionHandlers[opt](this, options[opt], Init);\n      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    })();\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  function makeDisplay(place, docStart) {\n    var d = {};\n\n    var input = d.input = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none;\");\n    if (webkit) input.style.width = \"1000px\";\n    else input.setAttribute(\"wrap\", \"off\");\n    // if border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) input.style.border = \"1px solid black\";\n    input.setAttribute(\"autocorrect\", \"off\"); input.setAttribute(\"autocapitalize\", \"off\");\n\n    // Wraps and hides input textarea\n    d.inputDiv = elt(\"div\", [input], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The actual fake scrollbars.\n    d.scrollbarH = elt(\"div\", [elt(\"div\", null, null, \"height: 1px\")], \"CodeMirror-hscrollbar\");\n    d.scrollbarV = elt(\"div\", [elt(\"div\", null, null, \"width: 1px\")], \"CodeMirror-vscrollbar\");\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    // DIVs containing the selection and the actual code\n    d.lineDiv = elt(\"div\");\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n    d.cursor = elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\");\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    d.otherCursor = elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\");\n    // Used to measure text size\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],\n                         null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the text, causes scrolling\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerCutOff + \"px; width: 1px;\");\n    // Will contain the gutters, if any\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Helper element to properly size the gutter backgrounds\n    var scrollerInner = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], null, \"position: relative; min-height: 100%\");\n    // Provides scrolling\n    d.scroller = elt(\"div\", [scrollerInner], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.scroller], \"CodeMirror\");\n    // Work around IE7 z-index bug\n    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = \"1px\"; d.inputDiv.style.position = \"absolute\"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = \"18px\";\n\n    // Current visible range (may be bigger than the view window).\n    d.viewOffset = d.lastSizeC = 0;\n    d.showingFrom = d.showingTo = docStart;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = \"\";\n    // Set to true when a non-horizontal-scrolling widget is added. As\n    // an optimization, widget aligning is skipped when d is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we currently expect input to appear\n    // (after some event like 'keypress' or 'input') and are polling\n    // intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n    // True when a drag from the editor is active\n    d.draggingText = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = null;\n    d.measureLineCache = [];\n    d.measureLineCachePos = 0;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string instead of the (large) selection.\n    d.inaccurateSelection = false;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    return d;\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      cm.display.wrapper.className += \" CodeMirror-wrap\";\n      cm.display.sizer.style.minWidth = \"\";\n    } else {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-wrap\", \"\");\n      computeMaxLength(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm.display, cm.doc.height);}, 100);\n  }\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line))\n        return 0;\n      else if (wrapping)\n        return (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var style = keyMap[cm.options.keyMap].style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") +\n      (style ? \" cm-keymap-\" + style : \"\");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n  }\n\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n  }\n\n  function lineLength(doc, line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find();\n      cur = getLine(doc, found.from.line);\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find();\n      len -= cur.text.length - found.from.ch;\n      cur = getLine(doc, found.to.line);\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  function computeMaxLength(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(doc, d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(doc, line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = false;\n    for (var i = 0; i < options.gutters.length; ++i) {\n      if (options.gutters[i] == \"CodeMirror-linenumbers\") {\n        if (options.lineNumbers) found = true;\n        else options.gutters.splice(i--, 1);\n      }\n    }\n    if (!found && options.lineNumbers)\n      options.gutters.push(\"CodeMirror-linenumbers\");\n  }\n\n  // SCROLLBARS\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content. Optionally force a scrollTop.\n  function updateScrollbars(d /* display */, docHeight) {\n    var totalHeight = docHeight + 2 * paddingTop(d);\n    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + \"px\";\n    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth;\n    var needsV = scrollHeight > d.scroller.clientHeight;\n    if (needsV) {\n      d.scrollbarV.style.display = \"block\";\n      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n      d.scrollbarV.firstChild.style.height =\n        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + \"px\";\n    } else d.scrollbarV.style.display = \"\";\n    if (needsH) {\n      d.scrollbarH.style.display = \"block\";\n      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n      d.scrollbarH.firstChild.style.width =\n        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + \"px\";\n    } else d.scrollbarH.style.display = \"\";\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n\n    if (mac_geLion && scrollbarWidth(d.measure) === 0)\n      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? \"18px\" : \"12px\";\n  }\n\n  function visibleLines(display, doc, viewPort) {\n    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;\n    if (typeof viewPort == \"number\") top = viewPort;\n    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}\n    top = Math.floor(top - paddingTop(display));\n    var bottom = Math.ceil(top + height);\n    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};\n  }\n\n  // LINE NUMBERS\n\n  function alignHorizontally(cm) {\n    var display = cm.display;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, l = comp + \"px\";\n    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {\n      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n  function compensateForHScroll(display) {\n    return getRect(display.scroller).left - getRect(display.sizer).left;\n  }\n\n  // DISPLAY DRAWING\n\n  function updateDisplay(cm, changes, viewPort) {\n    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo;\n    var updated = updateDisplayInner(cm, changes, viewPort);\n    if (updated) {\n      signalLater(cm, \"update\", cm);\n      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)\n        signalLater(cm, \"viewportChange\", cm, cm.display.showingFrom, cm.display.showingTo);\n    }\n    updateSelection(cm);\n    updateScrollbars(cm.display, cm.doc.height);\n\n    return updated;\n  }\n\n  // Uses a set of changes plus the current scroll position to\n  // determine which DOM updates have to be made, and makes the\n  // updates.\n  function updateDisplayInner(cm, changes, viewPort) {\n    var display = cm.display, doc = cm.doc;\n    if (!display.wrapper.clientWidth) {\n      display.showingFrom = display.showingTo = doc.first;\n      display.viewOffset = 0;\n      return;\n    }\n\n    // Compute the new visible window\n    // If scrollTop is specified, use that to determine which lines\n    // to render instead of the current scrollbar position.\n    var visible = visibleLines(display, doc, viewPort);\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (changes.length == 0 &&\n        visible.from > display.showingFrom && visible.to < display.showingTo)\n      return;\n\n    if (maybeUpdateLineNumberWidth(cm))\n      changes = [{from: doc.first, to: doc.first + doc.size}];\n    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + \"px\";\n    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : \"0\";\n\n    // Used to determine which lines need their line numbers updated\n    var positionsChangedFrom = Infinity;\n    if (cm.options.lineNumbers)\n      for (var i = 0; i < changes.length; ++i)\n        if (changes[i].diff) { positionsChangedFrom = changes[i].from; break; }\n\n    var end = doc.first + doc.size;\n    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, visible.to + cm.options.viewportMargin);\n    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);\n    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);\n    if (sawCollapsedSpans) {\n      from = lineNo(visualLine(doc, getLine(doc, from)));\n      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;\n    }\n\n    // Create a range of theoretically intact lines, and punch holes\n    // in that using the change info.\n    var intact = [{from: Math.max(display.showingFrom, doc.first),\n                   to: Math.min(display.showingTo, end)}];\n    if (intact[0].from >= intact[0].to) intact = [];\n    else intact = computeIntact(intact, changes);\n    // When merged lines are present, we might have to reduce the\n    // intact ranges because changes in continued fragments of the\n    // intact lines do require the lines to be redrawn.\n    if (sawCollapsedSpans)\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i], merged;\n        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {\n          var newTo = merged.find().from.line;\n          if (newTo > range.from) range.to = newTo;\n          else { intact.splice(i--, 1); break; }\n        }\n      }\n\n    // Clip off the parts that won't be visible\n    var intactLines = 0;\n    for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i];\n      if (range.from < from) range.from = from;\n      if (range.to > to) range.to = to;\n      if (range.from >= range.to) intact.splice(i--, 1);\n      else intactLines += range.to - range.from;\n    }\n    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {\n      updateViewOffset(cm);\n      return;\n    }\n    intact.sort(function(a, b) {return a.from - b.from;});\n\n    var focused = document.activeElement;\n    if (intactLines < (to - from) * .7) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n    display.lineDiv.style.display = \"\";\n    if (document.activeElement != focused && focused.offsetHeight) focused.focus();\n\n    var different = from != display.showingFrom || to != display.showingTo ||\n      display.lastSizeC != display.wrapper.clientHeight;\n    // This is just a bogus formula that detects when the editor is\n    // resized or the font size changes.\n    if (different) display.lastSizeC = display.wrapper.clientHeight;\n    display.showingFrom = from; display.showingTo = to;\n    startWorker(cm, 100);\n\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {\n      if (ie_lt8) {\n        var bot = node.offsetTop + node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = getRect(node);\n        height = box.bottom - box.top;\n      }\n      var diff = node.lineObj.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(node.lineObj, height);\n        var widgets = node.lineObj.widgets;\n        if (widgets) for (var i = 0; i < widgets.length; ++i)\n          widgets[i].height = widgets[i].node.offsetHeight;\n      }\n    }\n    updateViewOffset(cm);\n\n    if (visibleLines(display, doc, viewPort).to > to)\n      updateDisplayInner(cm, [], viewPort);\n    return true;\n  }\n\n  function updateViewOffset(cm) {\n    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));\n    // Position the mover div to align with the current virtual scroll position\n    cm.display.mover.style.top = off + \"px\";\n  }\n\n  function computeIntact(intact, changes) {\n    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n      var change = changes[i], intact2 = [], diff = change.diff || 0;\n      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n        var range = intact[j];\n        if (change.to <= range.from && change.diff) {\n          intact2.push({from: range.from + diff, to: range.to + diff});\n        } else if (change.to <= range.from || change.from >= range.to) {\n          intact2.push(range);\n        } else {\n          if (change.from > range.from)\n            intact2.push({from: range.from, to: change.from});\n          if (change.to < range.to)\n            intact2.push({from: change.to + diff, to: range.to + diff});\n        }\n      }\n      intact = intact2;\n    }\n    return intact;\n  }\n\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft;\n      width[cm.options.gutters[i]] = n.offsetWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n    var dims = getDimensions(cm);\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))\n      removeChildren(display.lineDiv);\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = \"none\";\n        node.lineObj = null;\n      } else {\n        node.parentNode.removeChild(node);\n      }\n      return next;\n    }\n\n    var nextIntact = intact.shift(), lineN = from;\n    cm.doc.iter(from, to, function(line) {\n      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();\n      if (lineIsHidden(cm.doc, line)) {\n        if (line.height != 0) updateLineHeight(line, 0);\n        if (line.widgets && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i)\n          if (line.widgets[i].showIfHidden) {\n            var prev = cur.previousSibling;\n            if (/pre/i.test(prev.nodeName)) {\n              var wrap = elt(\"div\", null, null, \"position: relative\");\n              prev.parentNode.replaceChild(wrap, prev);\n              wrap.appendChild(prev);\n              prev = wrap;\n            }\n            var wnode = prev.appendChild(elt(\"div\", [line.widgets[i].node], \"CodeMirror-linewidget\"));\n            positionLineWidget(line.widgets[i], wnode, prev, dims);\n          }\n      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {\n        // This line is intact. Skip to the actual node. Update its\n        // line number if needed.\n        while (cur.lineObj != line) cur = rm(cur);\n        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)\n          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));\n        cur = cur.nextSibling;\n      } else {\n        // For lines with widgets, make an attempt to find and reuse\n        // the existing element, so that widgets aren't needlessly\n        // removed and re-inserted into the dom\n        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)\n          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }\n        // This line needs to be generated.\n        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);\n        if (lineNode != reuse) {\n          container.insertBefore(lineNode, cur);\n        } else {\n          while (cur != reuse) cur = rm(cur);\n          cur = cur.nextSibling;\n        }\n\n        lineNode.lineObj = line;\n      }\n      ++lineN;\n    });\n    while (cur) cur = rm(cur);\n  }\n\n  function buildLineElement(cm, line, lineNo, dims, reuse) {\n    var lineElement = lineContent(cm, line);\n    var markers = line.gutterMarkers, display = cm.display, wrap;\n\n    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)\n      return lineElement;\n\n    // Lines with gutter elements, widgets or a background class need\n    // to be wrapped again, and have the extra elements added to the\n    // wrapper div\n\n    if (reuse) {\n      reuse.alignable = null;\n      var isOk = true, widgetsSeen = 0;\n      for (var n = reuse.firstChild, next; n; n = next) {\n        next = n.nextSibling;\n        if (!/\\bCodeMirror-linewidget\\b/.test(n.className)) {\n          reuse.removeChild(n);\n        } else {\n          for (var i = 0, first = true; i < line.widgets.length; ++i) {\n            var widget = line.widgets[i], isFirst = false;\n            if (!widget.above) { isFirst = first; first = false; }\n            if (widget.node == n.firstChild) {\n              positionLineWidget(widget, n, reuse, dims);\n              ++widgetsSeen;\n              if (isFirst) reuse.insertBefore(lineElement, n);\n              break;\n            }\n          }\n          if (i == line.widgets.length) { isOk = false; break; }\n        }\n      }\n      if (isOk && widgetsSeen == line.widgets.length) {\n        wrap = reuse;\n        reuse.className = line.wrapClass || \"\";\n      }\n    }\n    if (!wrap) {\n      wrap = elt(\"div\", null, line.wrapClass, \"position: relative\");\n      wrap.appendChild(lineElement);\n    }\n    // Kludge to make sure the styled element lies behind the selection (by z-index)\n    if (line.bgClass)\n      wrap.insertBefore(elt(\"div\", null, line.bgClass + \" CodeMirror-linebackground\"), wrap.firstChild);\n    if (cm.options.lineNumbers || markers) {\n      var gutterWrap = wrap.insertBefore(elt(\"div\", null, null, \"position: absolute; left: \" +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"),\n                                         wrap.firstChild);\n      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        wrap.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineNo),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + display.lineNumInnerWidth + \"px\"));\n      if (markers)\n        for (var k = 0; k < cm.options.gutters.length; ++k) {\n          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n          if (found)\n            gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                       dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n        }\n    }\n    if (ie_lt8) wrap.style.zIndex = 2;\n    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      positionLineWidget(widget, node, wrap, dims);\n      if (widget.above)\n        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n    return wrap;\n  }\n\n  function positionLineWidget(widget, node, wrap, dims) {\n    if (widget.noHScroll) {\n      (wrap.alignable || (wrap.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // SELECTION / CURSOR\n\n  function updateSelection(cm) {\n    var display = cm.display;\n    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      updateSelectionCursor(cm);\n    else\n      display.cursor.style.display = display.otherCursor.style.display = \"none\";\n    if (!collapsed)\n      updateSelectionRange(cm);\n    else\n      display.selectionDiv.style.display = \"none\";\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    var headPos = cursorCoords(cm, cm.doc.sel.head, \"div\");\n    var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);\n    display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                                      headPos.top + lineOff.top - wrapOff.top)) + \"px\";\n    display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                                       headPos.left + lineOff.left - wrapOff.left)) + \"px\";\n  }\n\n  // No selection, plain cursor\n  function updateSelectionCursor(cm) {\n    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, \"div\");\n    display.cursor.style.left = pos.left + \"px\";\n    display.cursor.style.top = pos.top + \"px\";\n    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n    display.cursor.style.display = \"\";\n\n    if (pos.other) {\n      display.otherCursor.style.display = \"\";\n      display.otherCursor.style.left = pos.other.left + \"px\";\n      display.otherCursor.style.top = pos.other.top + \"px\";\n      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    } else { display.otherCursor.style.display = \"none\"; }\n  }\n\n  // Highlight selection\n  function updateSelectionRange(cm) {\n    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;\n    var fragment = document.createDocumentFragment();\n    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? clientWidth - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg, retTop) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length, rVal = retTop ? Infinity : -Infinity;\n      function coords(ch) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(dir == \"rtl\" ? to - 1 : from);\n        var rightPos = coords(dir == \"rtl\" ? from : to - 1);\n        var left = leftPos.left, right = rightPos.right;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = pl;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = clientWidth;\n        if (fromArg == null && from == 0) left = pl;\n        rVal = retTop ? Math.min(rightPos.top, rVal) : Math.max(rightPos.bottom, rVal);\n        if (left < pl + 1) left = pl;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return rVal;\n    }\n\n    if (sel.from.line == sel.to.line) {\n      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n    } else {\n      var fromObj = getLine(doc, sel.from.line);\n      var cur = fromObj, merged, path = [sel.from.line, sel.from.ch], singleLine;\n      while (merged = collapsedSpanAtEnd(cur)) {\n        var found = merged.find();\n        path.push(found.from.ch, found.to.line, found.to.ch);\n        if (found.to.line == sel.to.line) {\n          path.push(sel.to.ch);\n          singleLine = true;\n          break;\n        }\n        cur = getLine(doc, found.to.line);\n      }\n\n      // This is a single, merged line\n      if (singleLine) {\n        for (var i = 0; i < path.length; i += 3)\n          drawForLine(path[i], path[i+1], path[i+2]);\n      } else {\n        var middleTop, middleBot, toObj = getLine(doc, sel.to.line);\n        if (sel.from.ch)\n          // Draw the first line of selection.\n          middleTop = drawForLine(sel.from.line, sel.from.ch, null, false);\n        else\n          // Simply include it in the middle block.\n          middleTop = heightAtLine(cm, fromObj) - display.viewOffset;\n\n        if (!sel.to.ch)\n          middleBot = heightAtLine(cm, toObj) - display.viewOffset;\n        else\n          middleBot = drawForLine(sel.to.line, collapsedSpanAtStart(toObj) ? null : 0, sel.to.ch, true);\n\n        if (middleTop < middleBot) add(pl, middleTop, null, middleBot);\n      }\n    }\n\n    removeChildrenAndAdd(display.selectionDiv, fragment);\n    display.selectionDiv.style.display = \"\";\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursor.style.visibility = display.otherCursor.style.visibility = \"\";\n    display.blinker = setInterval(function() {\n      if (!display.cursor.offsetHeight) return;\n      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n    }, cm.options.cursorBlinkRate);\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.showingTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changed = [], prevChange;\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {\n      if (doc.frontier >= cm.display.showingFrom) { // Visible\n        var oldStyles = line.styles;\n        line.styles = highlightLine(cm, line, state);\n        var ischange = !oldStyles || oldStyles.length != line.styles.length;\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) {\n          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;\n          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});\n        }\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changed.length)\n      operation(cm, function() {\n        for (var i = 0; i < changed.length; ++i)\n          regChange(this, changed[i].start, changed[i].end);\n      })();\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n) {\n    var minindent, minline, doc = cm.doc;\n    for (var search = n, lim = n - 100; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n) {\n    var doc = cm.doc, display = cm.display;\n      if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingLeft(display) {\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", null, null, \"text-align: left\")).appendChild(elt(\"span\", \"x\"));\n    return e.offsetLeft;\n  }\n\n  function measureChar(cm, line, ch, data) {\n    var dir = -1;\n    data = data || measureLine(cm, line);\n\n    for (var pos = ch;; pos += dir) {\n      var r = data[pos];\n      if (r) break;\n      if (dir < 0 && pos == 0) dir = 1;\n    }\n    return {left: pos < ch ? r.right : r.left,\n            right: pos > ch ? r.left : r.right,\n            top: r.top, bottom: r.bottom};\n  }\n\n  function findCachedMeasurement(cm, line) {\n    var cache = cm.display.measureLineCache;\n    for (var i = 0; i < cache.length; ++i) {\n      var memo = cache[i];\n      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&\n          cm.display.scroller.clientWidth == memo.width &&\n          memo.classes == line.textClass + \"|\" + line.bgClass + \"|\" + line.wrapClass)\n        return memo.measure;\n    }\n  }\n\n  function measureLine(cm, line) {\n    // First look in the cache\n    var measure = findCachedMeasurement(cm, line);\n    if (!measure) {\n      // Failing that, recompute and store result in cache\n      measure = measureLineInner(cm, line);\n      var cache = cm.display.measureLineCache;\n      var memo = {text: line.text, width: cm.display.scroller.clientWidth,\n                  markedSpans: line.markedSpans, measure: measure,\n                  classes: line.textClass + \"|\" + line.bgClass + \"|\" + line.wrapClass};\n      if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;\n      else cache.push(memo);\n    }\n    return measure;\n  }\n\n  function measureLineInner(cm, line) {\n    var display = cm.display, measure = emptyArray(line.text.length);\n    var pre = lineContent(cm, line, measure);\n\n    // IE does not cache element positions of inline elements between\n    // calls to getBoundingClientRect. This makes the loop below,\n    // which gathers the positions of all the characters on the line,\n    // do an amount of layout work quadratic to the number of\n    // characters. When line wrapping is off, we try to improve things\n    // by first subdividing the line into a bunch of inline blocks, so\n    // that IE can reuse most of the layout information from caches\n    // for those blocks. This does interfere with line wrapping, so it\n    // doesn't work when wrapping is on, but in that case the\n    // situation is slightly better, since IE does cache line-wrapping\n    // information and only recomputes per-line.\n    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n      var fragment = document.createDocumentFragment();\n      var chunk = 10, n = pre.childNodes.length;\n      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n        var wrap = elt(\"div\", null, null, \"display: inline-block\");\n        for (var j = 0; j < chunk && n; ++j) {\n          wrap.appendChild(pre.firstChild);\n          --n;\n        }\n        fragment.appendChild(wrap);\n      }\n      pre.appendChild(fragment);\n    }\n\n    removeChildrenAndAdd(display.measure, pre);\n\n    var outer = getRect(display.lineDiv);\n    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;\n    // Work around an IE7/8 bug where it will sometimes have randomly\n    // replaced our pre with a clone at this point.\n    if (ie_lt9 && display.measure.first != pre)\n      removeChildrenAndAdd(display.measure, pre);\n\n    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {\n      var size = getRect(cur);\n      var top = Math.max(0, size.top - outer.top), bot = Math.min(size.bottom - outer.top, maxBot);\n      for (var j = 0; j < vranges.length; j += 2) {\n        var rtop = vranges[j], rbot = vranges[j+1];\n        if (rtop > bot || rbot < top) continue;\n        if (rtop <= top && rbot >= bot ||\n            top <= rtop && bot >= rbot ||\n            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {\n          vranges[j] = Math.min(top, rtop);\n          vranges[j+1] = Math.max(bot, rbot);\n          break;\n        }\n      }\n      if (j == vranges.length) vranges.push(top, bot);\n      var right = size.right;\n      if (cur.measureRight) right = getRect(cur.measureRight).left;\n      data[i] = {left: size.left - outer.left, right: right - outer.left, top: j};\n    }\n    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {\n      var vr = cur.top;\n      cur.top = vranges[vr]; cur.bottom = vranges[vr+1];\n    }\n\n    return data;\n  }\n\n  function measureLineWidth(cm, line) {\n    var hasBadSpan = false;\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {\n      var sp = line.markedSpans[i];\n      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;\n    }\n    var cached = !hasBadSpan && findCachedMeasurement(cm, line);\n    if (cached) return measureChar(cm, line, line.text.length, cached).right;\n\n    var pre = lineContent(cm, line);\n    var end = pre.appendChild(zeroWidthElement(cm.display.measure));\n    removeChildrenAndAdd(cm.display.measure, pre);\n    return getRect(end).right - getRect(cm.display.lineDiv).left;\n  }\n\n  function clearCaches(cm) {\n    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;\n    cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  // Context is one of \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), or \"page\"\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(cm, lineObj);\n    if (context != \"local\") yOff -= cm.display.viewOffset;\n    if (context == \"page\") {\n      var lOff = getRect(cm.display.lineSpace);\n      yOff += lOff.top + (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n      var xOff = lOff.left + (window.pageXOffset || (document.documentElement || document.body).scrollLeft);\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  function charCoords(cm, pos, context, lineObj) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch), context);\n  }\n\n  function cursorCoords(cm, pos, context, lineObj, measurement) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!measurement) measurement = measureLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureChar(cm, lineObj, ch, measurement);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var main, other, linedir = order[0].level;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i], rtl = part.level % 2, nb, here;\n      if (part.from < ch && part.to > ch) return get(ch, rtl);\n      var left = rtl ? part.to : part.from, right = rtl ? part.from : part.to;\n      if (left == ch) {\n        // IE returns bogus offsets and widths for edges where the\n        // direction flips, but only for the side with the lower\n        // level. So we try to use the side with the higher level.\n        if (i && part.level < (nb = order[i-1]).level) here = get(nb.level % 2 ? nb.from : nb.to - 1, true);\n        else here = get(rtl && part.from != part.to ? ch - 1 : ch);\n        if (rtl == linedir) main = here; else other = here;\n      } else if (right == ch) {\n        var nb = i < order.length - 1 && order[i+1];\n        if (!rtl && nb && nb.from == nb.to) continue;\n        if (nb && part.level < nb.level) here = get(nb.level % 2 ? nb.to - 1 : nb.from);\n        else here = get(rtl ? ch : ch - 1, true);\n        if (rtl == linedir) main = here; else other = here;\n      }\n    }\n    if (linedir && !ch) other = get(order[0].to - 1);\n    if (!main) return other;\n    if (other) main.other = other;\n    return main;\n  }\n\n  function PosMaybeOutside(line, ch, outside) {\n    var pos = new Pos(line, ch);\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Coords must be lineSpace-local\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosMaybeOutside(doc.first, 0, true);\n    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineNo > last)\n      return PosMaybeOutside(doc.first + doc.size - 1, getLine(doc, last).text.length, true);\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find();\n      if (merged && found.ch >= mergedPos.from.ch)\n        lineNo = mergedPos.to.line;\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(cm, lineObj);\n    var wrongLine = false, cWidth = cm.display.wrapper.clientWidth;\n    var measurement = measureLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\",\n                            lineObj, measurement);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return Math.max(0, sp.left - cWidth);\n      else if (innerOff < sp.top) return sp.left + cWidth;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosMaybeOutside(lineNo, to, toOutside);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var after = x - fromX < toX - x, ch = after ? from : to;\n        while (isExtendingChar.test(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosMaybeOutside(lineNo, ch, after ? fromOutside : toOutside);\n        pos.after = after;\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist -= step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist = step;}\n    }\n  }\n\n  var measureText;\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"x\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var width = anchor.offsetWidth;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap changes in such a way that each\n  // change won't have to update the cursor and display (which would\n  // be awkward, slow, and error-prone), but instead updates are\n  // batched and then all combined and executed at once.\n\n  var nextOpId = 0;\n  function startOperation(cm) {\n    cm.curOp = {\n      // An array of ranges of lines that have to be updated. See\n      // updateDisplay.\n      changes: [],\n      updateInput: null,\n      userSelChange: null,\n      textChanged: null,\n      selectionChanged: false,\n      updateMaxLine: false,\n      updateScrollPos: false,\n      id: ++nextOpId\n    };\n    if (!delayedCallbackDepth++) delayedCallbacks = [];\n  }\n\n  function endOperation(cm) {\n    var op = cm.curOp, doc = cm.doc, display = cm.display;\n    cm.curOp = null;\n\n    if (op.updateMaxLine) computeMaxLength(cm);\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      var width = measureLineWidth(cm, display.maxLine);\n      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + \"px\";\n      display.maxLineChanged = false;\n      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);\n      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)\n        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);\n    }\n    var newScrollPos, updated;\n    if (op.updateScrollPos) {\n      newScrollPos = op.updateScrollPos;\n    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible\n      var coords = cursorCoords(cm, doc.sel.head);\n      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n    }\n    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null)\n      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);\n    if (!updated && op.selectionChanged) updateSelection(cm);\n    if (op.updateScrollPos) {\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;\n      alignHorizontally(cm);\n    } else if (newScrollPos) {\n      scrollCursorIntoView(cm);\n    }\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      resetInput(cm, op.userSelChange);\n\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    var delayed;\n    if (!--delayedCallbackDepth) {\n      delayed = delayedCallbacks;\n      delayedCallbacks = null;\n    }\n    if (op.textChanged)\n      signal(cm, \"change\", cm, op.textChanged);\n    if (op.selectionChanged) signal(cm, \"cursorActivity\", cm);\n    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm1, f) {\n    return function() {\n      var cm = cm1 || this, withOp = !cm.curOp;\n      if (withOp) startOperation(cm);\n      try { var result = f.apply(cm, arguments); }\n      finally { if (withOp) endOperation(cm); }\n      return result;\n    };\n  }\n  function docOperation(f) {\n    return function() {\n      var withOp = this.cm && !this.cm.curOp, result;\n      if (withOp) startOperation(this.cm);\n      try { result = f.apply(this, arguments); }\n      finally { if (withOp) endOperation(this.cm); }\n      return result;\n    };\n  }\n  function runInOp(cm, f) {\n    var withOp = !cm.curOp, result;\n    if (withOp) startOperation(cm);\n    try { result = f(); }\n    finally { if (withOp) endOperation(cm); }\n    return result;\n  }\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    cm.curOp.changes.push({from: from, to: to, diff: lendiff});\n  }\n\n  // INPUT HANDLING\n\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // prevInput is a hack to work with IME. If we reset the textarea\n  // on every change, that breaks IME. So we look for changes\n  // compared to the previous content instead. (Modern browsers have\n  // events that indicate IME taking place, but these are not widely\n  // supported or compatible enough yet to rely on.)\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;\n    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm)) return false;\n    var text = input.value;\n    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n    // IE enjoys randomly deselecting our input's text when\n    // re-focusing. If the selection is gone but the cursor is at the\n    // start of the input, that's probably what happened.\n    if (ie && text && input.selectionStart === 0) {\n      resetInput(cm, true);\n      return false;\n    }\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    sel.shift = false;\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput[same] == text[same]) ++same;\n    var from = sel.from, to = sel.to;\n    if (same < prevInput.length)\n      from = Pos(from.line, from.ch - (prevInput.length - same));\n    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)\n      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));\n    var updateInput = cm.curOp.updateInput;\n    makeChange(cm.doc, {from: from, to: to, text: splitLines(text.slice(same)),\n                        origin: cm.state.pasteIncoming ? \"paste\" : \"+input\"}, \"end\");\n\n    cm.curOp.updateInput = updateInput;\n    if (text.length > 1000) input.value = cm.display.prevInput = \"\";\n    else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = false;\n    return true;\n  }\n\n  function resetInput(cm, user) {\n    var minimal, selected, doc = cm.doc;\n    if (!posEq(doc.sel.from, doc.sel.to)) {\n      cm.display.prevInput = \"\";\n      minimal = hasCopyEvent &&\n        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n      if (minimal) cm.display.input.value = \"-\";\n      else cm.display.input.value = selected || cm.getSelection();\n      if (cm.state.focused) selectInput(cm.display.input);\n    } else if (user) cm.display.prevInput = cm.display.input.value = \"\";\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != \"nocursor\" && (!mobile || document.activeElement != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    on(d.scroller, \"dblclick\", operation(cm, e_preventDefault));\n    on(d.lineSpace, \"selectstart\", function(e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!captureMiddleClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    on(d.scroller, \"scroll\", function() {\n      setScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    });\n    on(d.scrollbarV, \"scroll\", function() {\n      setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, \"scroll\", function() {\n      setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, \"mousedown\", reFocus);\n    on(d.scrollbarV, \"mousedown\", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    function onResize() {\n      // Might be a text scaling operation, clear size caches.\n      d.cachedCharWidth = d.cachedTextHeight = null;\n      clearCaches(cm);\n      runInOp(cm, bind(regChange, cm));\n    }\n    on(window, \"resize\", onResize);\n    // Above handler holds on to the editor and its data structures.\n    // Here we poll to unregister it when the editor is no longer in\n    // the document, so that it can be garbage-collected.\n    function unregister() {\n      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n      if (p) setTimeout(unregister, 5000);\n      else off(window, \"resize\", onResize);\n    }\n    setTimeout(unregister, 5000);\n\n    on(d.input, \"keyup\", operation(cm, function(e) {\n      if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n      if (e.keyCode == 16) cm.doc.sel.shift = false;\n    }));\n    on(d.input, \"input\", bind(fastPoll, cm));\n    on(d.input, \"keydown\", operation(cm, onKeyDown));\n    on(d.input, \"keypress\", operation(cm, onKeyPress));\n    on(d.input, \"focus\", bind(onFocus, cm));\n    on(d.input, \"blur\", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n      e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, \"dragstart\", function(e){onDragStart(cm, e);});\n      on(d.scroller, \"dragenter\", drag_);\n      on(d.scroller, \"dragover\", drag_);\n      on(d.scroller, \"drop\", operation(cm, onDrop));\n    }\n    on(d.scroller, \"paste\", function(e){\n      if (eventInWidget(d, e)) return;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n    on(d.input, \"paste\", function() {\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopy() {\n      if (d.inaccurateSelection) {\n        d.prevInput = \"\";\n        d.inaccurateSelection = false;\n        d.input.value = cm.getSelection();\n        selectInput(d.input);\n      }\n    }\n    on(d.input, \"cut\", prepareCopy);\n    on(d.input, \"copy\", prepareCopy);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, \"mouseup\", function() {\n        if (document.activeElement == d.input) d.input.blur();\n        focusInput(cm);\n    });\n  }\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n) return true;\n      if (/\\bCodeMirror-(?:line)?widget\\b/.test(n.className) ||\n          n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  function posFromMouse(cm, e, liberal) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||\n          target == display.scrollbarV || target == display.scrollbarV.firstChild ||\n          target == display.scrollbarFiller) return null;\n    }\n    var x, y, space = getRect(display.lineSpace);\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n    return coordsChar(cm, x - space.left, y - space.top);\n  }\n\n  var lastClick, lastDoubleClick;\n  function onMouseDown(e) {\n    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;\n    sel.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n\n    switch (e_button(e)) {\n    case 3:\n      if (captureMiddleClick) onContextMenu.call(cm, cm, e);\n      return;\n    case 2:\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      return;\n    }\n    // For button 1, if it was clicked inside the editor\n    // (posFromMouse returning non-null), we have to adjust the\n    // selection.\n    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}\n\n    if (!cm.state.focused) onFocus(cm);\n\n    var now = +new Date, type = \"single\";\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n      type = \"triple\";\n      e_preventDefault(e);\n      setTimeout(bind(focusInput, cm), 20);\n      selectLine(cm, start.line);\n    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n      e_preventDefault(e);\n      var word = findWordAt(getLine(doc, start.line).text, start);\n      extendSelection(cm.doc, word.from, word.to);\n    } else { lastClick = {time: now, pos: start}; }\n\n    var last = start;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&\n        !posLess(start, sel.from) && !posLess(sel.to, start) && type == \"single\") {\n      var dragEnd = operation(cm, function(e2) {\n        if (webkit) display.scroller.draggable = false;\n        cm.state.draggingText = false;\n        off(document, \"mouseup\", dragEnd);\n        off(display.scroller, \"drop\", dragEnd);\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          extendSelection(cm.doc, start);\n          focusInput(cm);\n        }\n      });\n      // Let the drag handler handle this.\n      if (webkit) display.scroller.draggable = true;\n      cm.state.draggingText = dragEnd;\n      // IE's approach to draggable\n      if (display.scroller.dragDrop) display.scroller.dragDrop();\n      on(document, \"mouseup\", dragEnd);\n      on(display.scroller, \"drop\", dragEnd);\n      return;\n    }\n    e_preventDefault(e);\n    if (type == \"single\") extendSelection(cm.doc, clipPos(doc, start));\n\n    var startstart = sel.from, startend = sel.to;\n\n    function doSelect(cur) {\n      if (type == \"single\") {\n        extendSelection(cm.doc, clipPos(doc, start), cur);\n        return;\n      }\n\n      startstart = clipPos(doc, startstart);\n      startend = clipPos(doc, startend);\n      if (type == \"double\") {\n        var word = findWordAt(getLine(doc, cur.line).text, cur);\n        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);\n        else extendSelection(cm.doc, startstart, word.to);\n      } else if (type == \"triple\") {\n        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));\n        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));\n      }\n    }\n\n    var editorSize = getRect(display.wrapper);\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true);\n      if (!cur) return;\n      if (!posEq(cur, last)) {\n        if (!cm.state.focused) onFocus(cm);\n        last = cur;\n        doSelect(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      var cur = posFromMouse(cm, e);\n      if (cur) doSelect(cur);\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n    }\n\n    var move = operation(cm, function(e) {\n      if (!ie && !e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  function onDrop(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))\n      return;\n    e_preventDefault(e);\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join(\"\\n\")), origin: \"paste\"}, \"around\");\n          }\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else {\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;\n          setSelection(cm.doc, pos, pos);\n          if (cm.state.draggingText) replaceRange(cm.doc, \"\", curFrom, curTo, \"paste\");\n          cm.replaceSelection(text, null, \"paste\");\n          focusInput(cm);\n          onFocus(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    var display = cm.display;\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n\n    if (mX >= Math.floor(getRect(display.gutters).right)) return false;\n    e_preventDefault(e);\n    if (!hasHandler(cm, \"gutterClick\")) return true;\n\n    var lineBox = getRect(display.lineDiv);\n    if (mY > lineBox.bottom) return true;\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && getRect(g).right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalLater(cm, \"gutterClick\", cm, line, gutter, e);\n        break;\n      }\n    }\n    return true;\n  }\n\n  function onDragStart(cm, e) {\n    if (eventInWidget(cm.display, e)) return;\n\n    var txt = cm.getSelection();\n    e.dataTransfer.setData(\"Text\", txt);\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      if (opera) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      if (safari) {\n        if (cm.display.dragImg) {\n          img = cm.display.dragImg;\n        } else {\n          cm.display.dragImg = img;\n          img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n          cm.display.wrapper.appendChild(img);\n        }\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (opera) img.parentNode.removeChild(img);\n    }\n  }\n\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplay(cm, [], val);\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplay(cm, []);\n  }\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n        if (cur.lineObj) {\n          cm.display.currentWheelTarget = cur;\n          break;\n        }\n      }\n    }\n\n    var display = cm.display, scroll = display.scroller;\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplay(cm, [], {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var doc = cm.doc, prevShift = doc.sel.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) doc.sel.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      doc.sel.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    maps.push(cm.options.keyMap);\n    if (cm.options.extraKeys) maps.unshift(cm.options.extraKeys);\n    return maps;\n  }\n\n  var maybeTransition;\n  function handleKeyBinding(cm, e) {\n    // Handle auto keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap)\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n    }, 50);\n\n    var name = keyName(e, true), handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey(\"Shift-\" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n             || lookupKey(name, keymaps, function(b) {\n                  if (typeof b == \"string\" && /^go[A-Z]/.test(b)) return doHandleBinding(cm, b);\n                });\n    } else {\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n    }\n    if (handled == \"stop\") handled = false;\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n    }\n    return handled;\n  }\n\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey(\"'\" + ch + \"'\", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (!cm.state.focused) onFocus(cm);\n    if (ie && e.keyCode == 27) { e.returnValue = false; }\n    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var code = e.keyCode;\n    // IE does strange things with escape.\n    cm.doc.sel.shift = code == 16 || e.shiftKey;\n    // First give onKeyEvent option a chance to handle this.\n    var handled = handleKeyBinding(cm, e);\n    if (opera) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\");\n    }\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (this.options.electricChars && this.doc.mode.electricChars &&\n        this.options.smartIndent && !isReadOnly(this) &&\n        this.doc.mode.electricChars.indexOf(ch) > -1)\n      setTimeout(operation(cm, function() {indentLine(cm, cm.doc.sel.to.line, \"smart\");}), 75);\n    if (handleCharBinding(cm, e, ch)) return;\n    fastPoll(cm);\n  }\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      if (cm.display.wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n        cm.display.wrapper.className += \" CodeMirror-focused\";\n      resetInput(cm, true);\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-focused\", \"\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);\n  }\n\n  var detectingSelectAll;\n  function onContextMenu(cm, e) {\n    var display = cm.display, sel = cm.doc.sel;\n    if (eventInWidget(display, e)) return;\n\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || opera) return; // Opera is difficult.\n    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))\n      operation(cm, setSelection)(cm.doc, pos, pos);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = \"absolute\";\n    display.input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n      \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: white; outline: none;\" +\n      \"border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);\";\n    focusInput(cm);\n    resetInput(cm, true);\n    // Adds \"Select all\" to context menu in FF\n    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = \" \";\n\n    function rehide() {\n      display.inputDiv.style.position = \"relative\";\n      display.input.style.cssText = oldCSS;\n      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all\n      if (display.input.selectionStart != null && (!ie || ie_lt9)) {\n        clearTimeout(detectingSelectAll);\n        var extval = display.input.value = \" \" + (posEq(sel.from, sel.to) ? \"\" : display.input.value), i = 0;\n        display.prevInput = \" \";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n        var poll = function(){\n          if (display.prevInput == \" \" && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        };\n        detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (captureMiddleClick) {\n      e_stop(e);\n      var mouseup = function() {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  // UPDATING\n\n  function changeEnd(change) {\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  }\n\n  // Make sure a position will be valid after the given change.\n  function clipPostChange(doc, change, pos) {\n    if (!posLess(change.from, pos)) return clipPos(doc, pos);\n    var diff = (change.text.length - 1) - (change.to.line - change.from.line);\n    if (pos.line > change.to.line + diff) {\n      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;\n      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);\n      return clipToLen(pos, getLine(doc, preLine).text.length);\n    }\n    if (pos.line == change.to.line + diff)\n      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +\n                       getLine(doc, change.to.line).text.length - change.to.ch);\n    var inside = pos.line - change.from.line;\n    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));\n  }\n\n  // Hint can be null|\"end\"|\"start\"|\"around\"|{anchor,head}\n  function computeSelAfterChange(doc, change, hint) {\n    if (hint && typeof hint == \"object\") // Assumed to be {anchor, head} object\n      return {anchor: clipPostChange(doc, change, hint.anchor),\n              head: clipPostChange(doc, change, hint.head)};\n\n    if (hint == \"start\") return {anchor: change.from, head: change.from};\n\n    var end = changeEnd(change);\n    if (hint == \"around\") return {anchor: change.from, head: end};\n    if (hint == \"end\") return {anchor: end, head: end};\n\n    // hint is null, leave the selection alone as much as possible\n    var adjustPos = function(pos) {\n      if (posLess(pos, change.from)) return pos;\n      if (!posLess(change.to, pos)) return end;\n\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n      if (pos.line == change.to.line) ch += end.ch - change.to.ch;\n      return Pos(line, ch);\n    };\n    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};\n  }\n\n  function filterChange(doc, change) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      update: function(from, to, text, origin) {\n        if (from) this.from = clipPos(doc, from);\n        if (to) this.to = clipPos(doc, to);\n        if (text) this.text = text;\n        if (origin !== undefined) this.origin = origin;\n      },\n      cancel: function() { this.canceled = true; }\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Replace the range from from to to by the strings in replacement.\n  // change is a {from, to, text [, origin]} object\n  function makeChange(doc, change, selUpdate, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [\"\"]});\n      if (split.length)\n        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);\n    } else {\n      makeChangeNoReadonly(doc, change, selUpdate);\n    }\n  }\n\n  function makeChangeNoReadonly(doc, change, selUpdate) {\n    var selAfter = computeSelAfterChange(doc, change, selUpdate);\n    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  function makeChangeFromHistory(doc, type) {\n    var hist = doc.history;\n    var event = (type == \"undo\" ? hist.done : hist.undone).pop();\n    if (!event) return;\n    hist.dirtyCounter += type == \"undo\" ? -1 : 1;\n\n    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,\n                anchorAfter: event.anchorBefore, headAfter: event.headBefore};\n    (type == \"undo\" ? hist.undone : hist.done).push(anti);\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      anti.changes.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change, null)\n                    : {anchor: event.anchorBefore, head: event.headBefore};\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      var rebased = [];\n\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  function shiftDoc(doc, distance) {\n    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}\n    doc.first += distance;\n    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);\n    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);\n    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);\n  }\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);\n    else updateDoc(doc, change, spans, selAfter);\n  }\n\n  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(doc, line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    regChange(cm, from.line, to.line + 1, lendiff);\n    if (hasHandler(cm, \"change\")) {\n      var changeObj = {from: from, to: to, text: change.text, origin: change.origin};\n      if (cm.curOp.textChanged) {\n        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else cm.curOp.textChanged = changeObj;\n    }\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);\n  }\n\n  // POSITION OBJECT\n\n  function Pos(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  }\n  CodeMirror.Pos = Pos;\n\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function copyPos(x) {return Pos(x.line, x.ch);}\n\n  // SELECTION\n\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\n  // If shift is held, this will move the selection anchor. Otherwise,\n  // it'll set the whole selection.\n  function extendSelection(doc, pos, other, bias) {\n    if (doc.sel.shift || doc.sel.extend) {\n      var anchor = doc.sel.anchor;\n      if (other) {\n        var posBefore = posLess(pos, anchor);\n        if (posBefore != posLess(other, anchor)) {\n          anchor = pos;\n          pos = other;\n        } else if (posBefore != posLess(pos, other)) {\n          pos = other;\n        }\n      }\n      setSelection(doc, anchor, pos, bias);\n    } else {\n      setSelection(doc, pos, other || pos, bias);\n    }\n    if (doc.cm) doc.cm.curOp.userSelChange = true;\n  }\n\n  function filterSelectionChange(doc, anchor, head) {\n    var obj = {anchor: anchor, head: head};\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);\n    return obj;\n  }\n\n  // Update the selection. Last two args are only used by\n  // updateDoc, since they have to be expressed in the line\n  // numbers before the update.\n  function setSelection(doc, anchor, head, bias, checkAtomic) {\n    if (!checkAtomic && hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n      var filtered = filterSelectionChange(doc, anchor, head);\n      head = filtered.head;\n      anchor = filtered.anchor;\n    }\n\n    var sel = doc.sel;\n    sel.goalColumn = null;\n    // Skip over atomic spans.\n    if (checkAtomic || !posEq(anchor, sel.anchor))\n      anchor = skipAtomic(doc, anchor, bias, checkAtomic != \"push\");\n    if (checkAtomic || !posEq(head, sel.head))\n      head = skipAtomic(doc, head, bias, checkAtomic != \"push\");\n\n    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n\n    sel.anchor = anchor; sel.head = head;\n    var inv = posLess(head, anchor);\n    sel.from = inv ? head : anchor;\n    sel.to = inv ? anchor : head;\n\n    if (doc.cm)\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  function reCheckSelection(cm) {\n    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, \"push\");\n  }\n\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line), toClear;\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear && m.clearOnEnter) {\n              (toClear || (toClear = [])).push(m);\n              continue;\n            } else if (!m.atomic) continue;\n            var newPos = m.find()[dir < 0 ? \"from\" : \"to\"];\n            if (posEq(newPos, curPos)) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n        if (toClear) for (var i = 0; i < toClear.length; ++i) toClear[i].clear();\n      }\n      return curPos;\n    }\n  }\n\n  // SCROLLING\n\n  function scrollCursorIntoView(cm) {\n    var coords = scrollPosIntoView(cm, cm.doc.sel.head);\n    if (!cm.state.focused) return;\n    var display = cm.display, box = getRect(display.sizer), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var hidden = display.cursor.style.display == \"none\";\n      if (hidden) {\n        display.cursor.style.display = \"\";\n        display.cursor.style.left = coords.left + \"px\";\n        display.cursor.style.top = (coords.top - display.viewOffset) + \"px\";\n      }\n      display.cursor.scrollIntoView(doScroll);\n      if (hidden) display.cursor.style.display = \"none\";\n    }\n  }\n\n  function scrollPosIntoView(cm, pos) {\n    for (;;) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var scrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, pt = paddingTop(display);\n    y1 += pt; y2 += pt;\n    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};\n    var docBottom = cm.doc.height + 2 * pt;\n    var atTop = y1 < pt + 10, atBottom = y2 + pt > docBottom - 10;\n    if (y1 < screentop) result.scrollTop = atTop ? 0 : Math.max(0, y1);\n    else if (y2 > screentop + screen) result.scrollTop = (atBottom ? docBottom : y2) - screen;\n\n    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;\n    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;\n    var gutterw = display.gutters.offsetWidth;\n    var atLeft = x1 < gutterw + 10;\n    if (x1 < screenleft + gutterw || atLeft) {\n      if (atLeft) x1 = 0;\n      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n    } else if (x2 > screenw + screenleft - 3) {\n      result.scrollLeft = x2 + 10 - screenw;\n    }\n    return result;\n  }\n\n  function updateScrollPos(cm, left, top) {\n    cm.curOp.updateScrollPos = {scrollLeft: left, scrollTop: top};\n  }\n\n  function addToScrollPos(cm, left, top) {\n    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});\n    var scroll = cm.display.scroller;\n    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));\n    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));\n  }\n\n  // API UTILITIES\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc;\n    if (!how) how = \"add\";\n    if (how == \"smart\") {\n      if (!cm.doc.mode.indent) how = \"prev\";\n      else var state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (how == \"smart\") {\n      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString)\n      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n  }\n\n  function changeLine(cm, handle, op) {\n    var no = handle, line = handle, doc = cm.doc;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no)) regChange(cm, no, no + 1);\n    else return null;\n    return line;\n  }\n\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") moveOnce();\n    else if (unit == \"column\") moveOnce(true);\n    else if (unit == \"word\") {\n      var sawWord = false;\n      for (;;) {\n        if (dir < 0) if (!moveOnce()) break;\n        if (isWordChar(lineObj.text.charAt(ch))) sawWord = true;\n        else if (sawWord) {if (dir < 0) {dir = 1; moveOnce();} break;}\n        if (dir > 0) if (!moveOnce()) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), dir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  function findWordAt(line, pos) {\n    var start = pos.ch, end = pos.ch;\n    if (line) {\n      if (pos.after === false || end == line.length) --start; else ++end;\n      var startChar = line.charAt(start);\n      var check = isWordChar(startChar) ? isWordChar :\n        /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);} :\n      function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n      while (start > 0 && check(line.charAt(start - 1))) --start;\n      while (end < line.length && check(line.charAt(end))) ++end;\n    }\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};\n  }\n\n  function selectLine(cm, line) {\n    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));\n  }\n\n  // PROTOTYPE\n\n  // The publicly visible API. Note that operation(null, f) means\n  // 'wrap f in an operation, performed on its `this` parameter'\n\n  CodeMirror.prototype = {\n    focus: function(){window.focus(); focusInput(this); onFocus(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map) {\n      this.state.keyMaps.push(map);\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if ((typeof map == \"string\" ? maps[i].name : maps[i]) == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: operation(null, function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: operation(null, function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        if (overlays[i].modeSpec == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: operation(null, function(n, dir, aggressive) {\n      if (typeof dir != \"string\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: operation(null, function(how) {\n      var sel = this.doc.sel;\n      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos) {\n      var doc = this.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line), mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null, // Deprecated, use 'type' instead\n              type: style || null,\n              state: state};\n    },\n\n    getStateAfter: function(line) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, sel = this.doc.sel;\n      if (start == null) pos = sel.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? sel.from : sel.to;\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords) {\n      var off = getRect(this.display.lineSpace);\n      var scrollY = window.pageYOffset || (document.documentElement || document.body).scrollTop;\n      var scrollX = window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n      return coordsChar(this, coords.left - off.left - scrollX, coords.top - off.top - scrollY);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n\n    setGutterMarker: operation(null, function(line, gutterID, value) {\n      return changeLine(this, line, function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: operation(null, function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regChange(cm, i, i + 1);\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp(\"\\\\b\" + cls + \"\\\\b\").test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n\n    removeLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var upd = cur.replace(new RegExp(\"^\" + cls + \"\\\\b\\\\s*|\\\\s*\\\\b\" + cls + \"\\\\b\"), \"\");\n          if (upd == cur) return false;\n          line[prop] = upd || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: operation(null, function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = (top + paddingTop(display)) + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: operation(null, onKeyDown),\n\n    execCommand: function(cmd) {return commands[cmd](this);},\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, pos;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to))\n        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);\n      else\n        pos = dir < 0 ? sel.from : sel.to;\n      extendSelection(this.doc, pos, pos, dir);\n    }),\n\n    deleteH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel;\n      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, \"\", sel.from, sel.to, \"+delete\");\n      else replaceRange(this.doc, \"\", sel.from, findPosH(this.doc, sel.head, dir, unit, false), \"+delete\");\n      this.curOp.userSelChange = true;\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: operation(null, function(dir, unit) {\n      var sel = this.doc.sel;\n      var pos = cursorCoords(this, sel.head, \"div\");\n      if (sel.goalColumn != null) pos.left = sel.goalColumn;\n      var target = findPosV(this, pos, dir, unit);\n\n      if (unit == \"page\") addToScrollPos(this, 0, charCoords(this, target, \"div\").top - pos.top);\n      extendSelection(this.doc, target, target, dir);\n      sel.goalColumn = pos.left;\n    }),\n\n    toggleOverwrite: function() {\n      if (this.state.overwrite = !this.state.overwrite)\n        this.display.cursor.className += \" CodeMirror-overwrite\";\n      else\n        this.display.cursor.className = this.display.cursor.className.replace(\" CodeMirror-overwrite\", \"\");\n    },\n\n    scrollTo: operation(null, function(x, y) {\n      updateScrollPos(this, x, y);\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: function(pos) {\n      if (typeof pos == \"number\") pos = Pos(pos, 0);\n      if (!pos || pos.line != null) {\n        pos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;\n        scrollPosIntoView(this, pos);\n      } else {\n        scrollIntoView(this, pos.left, pos.top, pos.right, pos.bottom);\n      }\n    },\n\n    setSize: function(width, height) {\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) this.display.wrapper.style.width = interpret(width);\n      if (height != null) this.display.wrapper.style.height = interpret(height);\n      this.refresh();\n    },\n\n    on: function(type, f) {on(this, type, f);},\n    off: function(type, f) {off(this, type, f);},\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: operation(null, function() {\n      clearCaches(this);\n      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);\n      regChange(this);\n    }),\n\n    swapDoc: operation(null, function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n\n  // OPTION DEFAULTS\n\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    loadMode(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"electricChars\", true);\n  option(\"rtlMoveVisually\", !windows);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", keyMapChanged);\n  option(\"extraKeys\", null);\n\n  option(\"onKeyEvent\", null);\n  option(\"onDragEvent\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {onBlur(cm); cm.display.input.blur();}\n    else if (!val) resetInput(cm, true);\n  });\n  option(\"dragDrop\", true);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorHeight\", 1);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 40, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec))\n      spec = mimeModes[spec];\n    else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec))\n      return CodeMirror.resolveMode(\"application/xml\");\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  CodeMirror.getMode = function(options, spec) {\n    spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    return modeObj;\n  };\n\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch)\n        cm.replaceRange(\"\", from, Pos(from.line + 1, 0), \"+delete\");\n      else cm.replaceRange(\"\", from, sel ? to : Pos(from.line), \"+delete\");\n    },\n    deleteLine: function(cm) {\n      var l = cm.getCursor().line;\n      cm.replaceRange(\"\", Pos(l, 0), Pos(l), \"+delete\");\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n    },\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor(), start = lineStart(cm, cur.line);\n      var line = cm.getLineHandle(start.line);\n      var order = getOrder(line);\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));\n      } else cm.extendSelection(start);\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\", \"end\", \"+input\");},\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.replaceSelection(\"\\t\", \"end\", \"+input\");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n    },\n    newlineAndIndent: function(cm) {\n      operation(cm, function() {\n        cm.replaceSelection(\"\\n\", \"end\", \"+input\");\n        cm.indentLine(cm.getCursor().line, null, true);\n      })();\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Alt-Up\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Down\": \"goDocEnd\",\n    \"Ctrl-Left\": \"goWordLeft\", \"Ctrl-Right\": \"goWordRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delWordBefore\", \"Ctrl-Delete\": \"delWordAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goWordLeft\",\n    \"Alt-Right\": \"goWordRight\", \"Cmd-Left\": \"goLineStart\", \"Cmd-Right\": \"goLineEnd\", \"Alt-Backspace\": \"delWordBefore\",\n    \"Ctrl-Alt-Backspace\": \"delWordAfter\", \"Alt-Delete\": \"delWordAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == \"string\") return keyMap[val];\n    else return val;\n  }\n\n  function lookupKey(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return \"stop\";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return \"stop\";\n\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done;\n    }\n  }\n  function isModifierKey(event) {\n    var name = keyNames[event.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n  function keyName(event, noShift) {\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = \"Alt-\" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = \"Ctrl-\" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n  }\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.keyName = keyName;\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = document.body;\n      // doc.activeElement occasionally throws on IE\n      try { hasFocus = document.activeElement; } catch(e) {}\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n  }\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == 0;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue;\n    },\n    indentation: function() {return countColumn(this.string, null, this.tabSize);},\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);}\n  };\n  CodeMirror.StringStream = StringStream;\n\n  // TEXTMARKERS\n\n  function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  }\n  CodeMirror.TextMarker = TextMarker;\n\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.to != null) max = lineNo(line);\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from != null)\n        min = lineNo(line);\n      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.collapsed && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm);\n    }\n    if (withOp) endOperation(cm);\n    signalLater(this, \"clear\");\n  };\n\n  TextMarker.prototype.find = function() {\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null || span.to != null) {\n        var found = lineNo(line);\n        if (span.from != null) from = Pos(found, span.from);\n        if (span.to != null) to = Pos(found, span.to);\n      }\n    }\n    if (this.type == \"bookmark\") return from;\n    return from && {from: from, to: to};\n  };\n\n  TextMarker.prototype.getOptions = function(copyWidget) {\n    var repl = this.replacedWith;\n    return {className: this.className,\n            inclusiveLeft: this.inclusiveLeft, inclusiveRight: this.inclusiveRight,\n            atomic: this.atomic,\n            collapsed: this.collapsed,\n            clearOnEnter: this.clearOnEnter,\n            replacedWith: copyWidget ? repl && repl.cloneNode(true) : repl,\n            readOnly: this.readOnly,\n            startStyle: this.startStyle, endStyle: this.endStyle};\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  function markText(doc, from, to, options, type) {\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type);\n    if (type == \"range\" && !posLess(from, to)) return marker;\n    if (options) copyObj(options, marker);\n    if (marker.replacedWith) {\n      marker.collapsed = true;\n      marker.replacedWith = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    }\n    if (marker.collapsed) sawCollapsedSpans = true;\n\n    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)\n        updateMaxLine = true;\n      var span = {from: null, to: null, marker: marker};\n      size += line.text.length;\n      if (curLine == from.line) {span.from = from.ch; size -= from.ch;}\n      if (curLine == to.line) {span.to = to.ch; size -= line.text.length - to.ch;}\n      if (marker.collapsed) {\n        if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);\n        if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);\n        else updateLineHeight(line, 0);\n      }\n      addMarkedSpan(line, span);\n      ++curLine;\n    });\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      if (collapsedAtStart != collapsedAtEnd)\n        throw new Error(\"Inserting collapsed marker overlapping an existing one\");\n      marker.size = size;\n      marker.atomic = true;\n    }\n    if (cm) {\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      if (marker.atomic) reCheckSelection(cm);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0, me = this; i < markers.length; ++i) {\n      markers[i].parent = this;\n      on(markers[i], \"clear\", function(){me.clear();});\n    }\n  }\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function() {\n    return this.primary.find();\n  };\n  SharedTextMarker.prototype.getOptions = function(copyWidget) {\n    var inner = this.primary.getOptions(copyWidget);\n    inner.shared = true;\n    return inner;\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.replacedWith;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.replacedWith = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  // TEXTMARKER SPANS\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || marker.type == \"bookmark\" && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({from: span.from,\n                                to: endsAfter ? null : span.to,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || marker.type == \"bookmark\" && span.from == endCh && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n                                to: span.to == null ? null : span.to - endCh,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find();\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;\n        var newParts = [j, 1];\n        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))\n          newParts.push({from: p.from, to: m.from});\n        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  function collapsedSpanAt(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if ((sp.from == null || sp.from < ch) &&\n          (sp.to == null || sp.to > ch) &&\n          (!found || found.width < sp.marker.width))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAt(line, -1); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAt(line, line.text.length + 1); }\n\n  function visualLine(doc, line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(doc, merged.find().from.line);\n    return line;\n  }\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find().to, endLine = getLine(doc, end.line);\n      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && sp.from == span.to &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // LINE WIDGETS\n\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n    for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.cm = cm;\n    this.node = node;\n  };\n  function widgetOperation(f) {\n    return function() {\n      var withOp = !this.cm.curOp;\n      if (withOp) startOperation(this.cm);\n      try {var result = f.apply(this, arguments);}\n      finally {if (withOp) endOperation(this.cm);}\n      return result;\n    };\n  }\n  LineWidget.prototype.clear = widgetOperation(function() {\n    var ws = this.line.widgets, no = lineNo(this.line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) this.line.widgets = null;\n    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));\n    regChange(this.cm, no, no + 1);\n  });\n  LineWidget.prototype.changed = widgetOperation(function() {\n    var oldH = this.height;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(this.line, this.line.height + diff);\n    var no = lineNo(this.line);\n    regChange(this.cm, no, no + 1);\n  });\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)\n      removeChildrenAndAdd(widget.cm.display.measure, elt(\"div\", [widget.node], null, \"position: relative\"));\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm, handle, function(line) {\n      (line.widgets || (line.widgets = [])).push(widget);\n      widget.line = line;\n      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {\n        var aboveVisible = heightAtLine(cm, line) < cm.display.scroller.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, 0, widget.height);\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  function makeLine(text, markedSpans, estimateHeight) {\n    var line = {text: text};\n    attachMarkedSpans(line, markedSpans);\n    line.height = estimateHeight ? estimateHeight(line) : 1;\n    return line;\n  }\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n    signalLater(line, \"change\");\n  }\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Run the given mode's parser over a line, update the styles\n  // array, which contains alternating fragments of text and CSS\n  // classes.\n  function runMode(cm, text, mode, state, f) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curText = \"\", curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize);\n    if (text == \"\" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      var style = mode.token(stream, state);\n      if (stream.pos > 5000) {\n        flattenSpans = false;\n        // Webkit seems to refuse to render text nodes longer than 57444 characters\n        stream.pos = Math.min(text.length, stream.start + 50000);\n        style = null;\n      }\n      var substr = stream.current();\n      stream.start = stream.pos;\n      if (!flattenSpans || curStyle != style) {\n        if (curText) f(curText, curStyle);\n        curText = substr; curStyle = style;\n      } else curText = curText + substr;\n    }\n    if (curText) f(curText, curStyle);\n  }\n\n  function highlightLine(cm, line, state) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen];\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(txt, style) {st.push(txt, style);});\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1;\n      runMode(cm, line.text, overlay.mode, true, function(txt, style) {\n        var start = i, len = txt.length;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (len) {\n          var cur = st[i], len_ = cur.length;\n          if (len_ <= len) {\n            len -= len_;\n          } else {\n            st.splice(i, 1, cur.slice(0, len), st[i+1], cur.slice(len));\n            len = 0;\n          }\n          i += 2;\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, txt, style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = cur ? cur + \" \" + style : style;\n          }\n        }\n      });\n    }\n\n    return st;\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen)\n      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array.\n  function processLine(cm, line, state) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(line.text, cm.options.tabSize);\n    if (line.text == \"\" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol() && stream.pos <= 5000) {\n      mode.token(stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  var styleToClassCache = {};\n  function styleToClass(style) {\n    if (!style) return null;\n    return styleToClassCache[style] ||\n      (styleToClassCache[style] = \"cm-\" + style.replace(/ +/g, \" cm-\"));\n  }\n\n  function lineContent(cm, realLine, measure) {\n    var merged, line = realLine, lineBefore, sawBefore, simple = true;\n    while (merged = collapsedSpanAtStart(line)) {\n      simple = false;\n      line = getLine(cm.doc, merged.find().from.line);\n      if (!lineBefore) lineBefore = line;\n    }\n\n    var builder = {pre: elt(\"pre\"), col: 0, pos: 0, display: !measure,\n                   measure: null, addedOne: false, cm: cm};\n    if (line.textClass) builder.pre.className = line.textClass;\n\n    do {\n      builder.measure = line == realLine && measure;\n      builder.pos = 0;\n      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n      if (measure && sawBefore && line != realLine && !builder.addedOne) {\n        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n        builder.addedOne = true;\n      }\n      var next = insertLineContent(line, builder, getLineStyles(cm, line));\n      sawBefore = line == lineBefore;\n      if (next) {\n        line = getLine(cm.doc, next.to.line);\n        simple = false;\n      }\n    } while (next);\n\n    if (measure && !builder.addedOne)\n      measure[0] = builder.pre.appendChild(simple ? elt(\"span\", \"\\u00a0\") : zeroWidthElement(cm.display.measure));\n    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))\n      builder.pre.appendChild(document.createTextNode(\"\\u00a0\"));\n\n    var order;\n    // Work around problem with the reported dimensions of single-char\n    // direction spans on IE (issue #1129). See also the comment in\n    // cursorCoords.\n    if (measure && ie && (order = getOrder(line))) {\n      var l = order.length - 1;\n      if (order[l].from == order[l].to) --l;\n      var last = order[l], prev = order[l - 1];\n      if (last.from + 1 == last.to && prev && last.level < prev.level) {\n        var span = measure[builder.pos - 1];\n        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),\n                                               span.nextSibling);\n      }\n    }\n\n    return builder.pre;\n  }\n\n  var tokenSpecialChars = /[\\t\\u0000-\\u0019\\u00ad\\u200b\\u2028\\u2029\\uFEFF]/g;\n  function buildToken(builder, text, style, startStyle, endStyle) {\n    if (!text) return;\n    if (!tokenSpecialChars.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        tokenSpecialChars.lastIndex = pos;\n        var m = tokenSpecialChars.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n          builder.col += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          builder.col += tabWidth;\n        } else {\n          var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n          token.title = \"\\\\u\" + m[0].charCodeAt(0).toString(16);\n          content.appendChild(token);\n          builder.col += 1;\n        }\n      }\n    }\n    if (style || startStyle || endStyle || builder.measure) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      return builder.pre.appendChild(elt(\"span\", [content], fullStyle));\n    }\n    builder.pre.appendChild(content);\n  }\n\n  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n    var wrapping = builder.cm.options.lineWrapping;\n    for (var i = 0; i < text.length; ++i) {\n      var ch = text.charAt(i), start = i == 0;\n      if (ch >= \"\\ud800\" && ch < \"\\udbff\" && i < text.length - 1) {\n        ch = text.slice(i, i + 2);\n        ++i;\n      } else if (i && wrapping &&\n                 spanAffectsWrapping.test(text.slice(i - 1, i + 1))) {\n        builder.pre.appendChild(elt(\"wbr\"));\n      }\n      var span = builder.measure[builder.pos] =\n        buildToken(builder, ch, style,\n                   start && startStyle, i == text.length - 1 && endStyle);\n      // In IE single-space nodes wrap differently than spaces\n      // embedded in larger text nodes, except when set to\n      // white-space: normal (issue #1268).\n      if (ie && wrapping && ch == \" \" && i && !/\\s/.test(text.charAt(i - 1)) &&\n          i < text.length - 1 && !/\\s/.test(text.charAt(i + 1)))\n        span.style.whiteSpace = \"normal\";\n      builder.pos += ch.length;\n    }\n    if (text.length) builder.addedOne = true;\n  }\n\n  function buildCollapsedSpan(builder, size, widget) {\n    if (widget) {\n      if (!builder.display) widget = widget.cloneNode(true);\n      builder.pre.appendChild(widget);\n      if (builder.measure && size) {\n        builder.measure[builder.pos] = widget;\n        builder.addedOne = true;\n      }\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, styles[i], styleToClass(styles[i+1]));\n      return;\n    }\n\n    var allText = line.text, len = allText.length;\n    var pos = 0, i = 1, text = \"\", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmark = null;\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = \"\"; }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n            if (m.collapsed && (!collapsed || collapsed.marker.width < m.width))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == \"bookmark\" && sp.from == pos && m.replacedWith)\n            foundBookmark = m.replacedWith;\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,\n                             collapsed.from != null && collapsed.marker.replacedWith);\n          if (collapsed.to == null) return collapsed.marker.find();\n        }\n        if (foundBookmark && !collapsed) buildCollapsedSpan(builder, 0, foundBookmark);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\");\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = styles[i++]; style = styleToClass(styles[i++]);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // First adjust the line structure\n    if (from.ch == 0 && to.ch == 0 && lastText == \"\") {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)\n        added.push(makeLine(text[i], spansFor(i), estimateHeight));\n      updateLine(lastLine, lastLine.text, lastSpans, estimateHeight);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        updateLine(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch),\n                   lastSpans, estimateHeight);\n      } else {\n        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)\n          added.push(makeLine(text[i], spansFor(i), estimateHeight));\n        added.push(makeLine(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        updateLine(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0), estimateHeight);\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      updateLine(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch),\n                 spansFor(0), estimateHeight);\n      doc.remove(from.line + 1, nlines);\n    } else {\n      updateLine(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0), estimateHeight);\n      updateLine(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans, estimateHeight);\n      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)\n        added.push(makeLine(text[i], spansFor(i), estimateHeight));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n    setSelection(doc, selAfter.anchor, selAfter.head, null, true);\n  }\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([makeLine(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.history = makeHistory();\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n\n    if (typeof text == \"string\") text = splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n    setValue: function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: splitLines(code), origin: \"setValue\"},\n                 {head: top, anchor: top}, true);\n    },\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n    setLine: function(line, text) {\n      if (isLine(this, line))\n        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));\n    },\n    removeLine: function(line) {\n      if (isLine(this, line))\n        replaceRange(this, \"\", Pos(line, 0), clipPos(this, Pos(line + 1, 0)));\n    },\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var sel = this.sel, pos;\n      if (start == null || start == \"head\") pos = sel.head;\n      else if (start == \"anchor\") pos = sel.anchor;\n      else if (start == \"end\" || start === false) pos = sel.to;\n      else pos = sel.from;\n      return copyPos(pos);\n    },\n    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},\n\n    setCursor: docOperation(function(line, ch, extend) {\n      var pos = clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line);\n      if (extend) extendSelection(this, pos);\n      else setSelection(this, pos, pos);\n    }),\n    setSelection: docOperation(function(anchor, head) {\n      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));\n    }),\n    extendSelection: docOperation(function(from, to) {\n      extendSelection(this, clipPos(this, from), to && clipPos(this, to));\n    }),\n\n    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},\n    replaceSelection: function(code, collapse, origin) {\n      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || \"around\");\n    },\n    undo: docOperation(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docOperation(function() {makeChangeFromHistory(this, \"redo\");}),\n\n    setExtending: function(val) {this.sel.extend = val;},\n\n    historySize: function() {\n      var hist = this.history;\n      return {undo: hist.done.length, redo: hist.undone.length};\n    },\n    clearHistory: function() {this.history = makeHistory();},\n\n    markClean: function() {\n      this.history.dirtyCounter = 0;\n      this.history.lastOp = this.history.lastOrigin = null;\n    },\n    isClean: function () {return this.history.dirtyCounter == 0;},\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = makeHistory();\n      hist.done = histData.done.slice(0);\n      hist.undone = histData.undone.slice(0);\n    },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,\n                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = makeHistory();\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;}\n  });\n\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // The Doc methods that should be available on CodeMirror instances\n  var dontDelegate = \"iter insert remove copy getEditor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) computeMaxLength(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  function getLine(chunk, n) {\n    n -= chunk.first;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n  function heightAtLine(cm, lineObj) {\n    lineObj = visualLine(cm.doc, lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function makeHistory() {\n    return {\n      // Arrays of history events. Doing something adds an event to\n      // done and clears undo. Undoing moves events from done to\n      // undone, redoing moves them in the other direction.\n      done: [], undone: [], undoDepth: Infinity,\n      // Used to track when changes can be merged into a single undo\n      // event\n      lastTime: 0, lastOp: null, lastOrigin: null,\n      // Used by the isClean() method\n      dirtyCounter: 0\n    };\n  }\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: change.from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  function addToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur = lst(hist.done);\n\n    if (cur &&\n        (hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastTime > time - 600) || change.origin.charAt(0) == \"*\"))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;\n    } else {\n      // Can not be merged, start a new event.\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,\n             anchorAfter: selAfter.anchor, headAfter: selAfter.head};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth)\n        hist.done.shift();\n      if (hist.dirtyCounter < 0)\n        // The user has made a change after undoing past the last clean state.\n        // We can never get back to a clean state now until markClean() is called.\n        hist.dirtyCounter = NaN;\n      else\n        hist.dirtyCounter++;\n    }\n    hist.lastTime = time;\n    hist.lastOp = opId;\n    hist.lastOrigin = change.origin;\n  }\n\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i], changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,\n                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSel(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }\n        if (to < cur.from.line) {\n          cur.from.line += diff;\n          cur.to.line += diff;\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!sub.copied) {\n        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);\n        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);\n        sub.copied = true;\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      } else {\n        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);\n        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT OPERATORS\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  function on(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  }\n\n  var delayedCallbacks, delayedCallbackDepth = 0;\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    if (!delayedCallbacks) {\n      ++delayedCallbackDepth;\n      delayedCallbacks = [];\n      setTimeout(fireDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      delayedCallbacks.push(bnd(arr[i]));\n  }\n\n  function fireDelayed() {\n    --delayedCallbackDepth;\n    var delayed = delayedCallbacks;\n    delayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {\n      if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n  CodeMirror.countColumn = countColumn;\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else node.select();\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  function createObj(base, props) {\n    function Obj() {}\n    Obj.prototype = base;\n    var inst = new Obj();\n    if (props) copyObj(props, inst);\n    return inst;\n  }\n\n  function copyObj(obj, target) {\n    if (!target) target = {};\n    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n    return target;\n  }\n\n  function emptyArray(size) {\n    for (var a = [], i = 0; i < size; ++i) a.push(undefined);\n    return a;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc]/;\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  var isExtendingChar = /[\\u0300-\\u036F\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\uA66F\\uA670-\\uA672\\uA674-\\uA67D\\uA69F\\udc00-\\udfff]/;\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") setTextContent(e, content);\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  function removeChildren(e) {\n    // IE will break all parent-child relations in subnodes when setting innerHTML\n    if (!ie) e.innerHTML = \"\";\n    else while (e.firstChild) e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = \"\";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  function getRect(node) {\n    return node.getBoundingClientRect();\n  }\n  CodeMirror.replaceGetRect = function(f) { getRect = f; };\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of regexps matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  var spanAffectsWrapping = /^$/; // Won't match any two-character string\n  if (gecko) spanAffectsWrapping = /$'/;\n  else if (safari && !/Version\\/([6-9]|\\d\\d)\\b/.test(navigator.userAgent)) spanAffectsWrapping = /\\-[^ \\-?]|\\?[^ !'\\\"\\),.\\-\\/:;\\?\\]\\}]/;\n  else if (webkit) spanAffectsWrapping = /[~!#%&*)=+}\\]|\\\"\\.>,:;][({[<]|-[^\\-?\\.]|\\?[\\w~`@#$%\\^&*(_=+{[|><]/;\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt(\"div\", null, null, \"width: 50px; height: 50px; overflow-x: scroll\");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n    }\n    if (zwspSupported) return elt(\"span\", \"\\u200b\");\n    else return elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == 'function';\n  })();\n\n  // KEY NAMING\n\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n                  46: \"Delete\", 59: \";\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 109: \"-\", 107: \"=\", 127: \"Delete\",\n                  186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n                  221: \"]\", 222: \"'\", 63276: \"PageUp\", 63277: \"PageDown\", 63275: \"End\", 63273: \"Home\",\n                  63234: \"Left\", 63232: \"Up\", 63235: \"Right\", 63233: \"Down\", 63302: \"Insert\", 63272: \"Delete\"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from)\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n    }\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(cm.doc, line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line;\n    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))\n      lineN = merged.find().to.line;\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN, ch);\n  }\n\n  // This is somewhat involved. It is needed in order to move\n  // 'visually' through bi-directional text -- i.e., pressing left\n  // should make the cursor go left, even when in RTL text. The\n  // tricky part is the 'jumps', where RTL and LTR text touch each\n  // other. This often requires the cursor offset to move more than\n  // one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var moveOneUnit = byUnit ? function(pos, dir) {\n      do pos += dir;\n      while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));\n      return pos;\n    } : function(pos, dir) { return pos + dir; };\n    var linedir = bidi[0].level;\n    for (var i = 0; i < bidi.length; ++i) {\n      var part = bidi[i], sticky = part.level % 2 == linedir;\n      if ((part.from < start && part.to > start) ||\n          (sticky && (part.from == start || part.to == start))) break;\n    }\n    var target = moveOneUnit(start, part.level % 2 ? -dir : dir);\n\n    while (target != null) {\n      if (part.level % 2 == linedir) {\n        if (target < part.from || target > part.to) {\n          part = bidi[i += dir];\n          target = part && (dir > 0 == part.level % 2 ? moveOneUnit(part.to, -1) : moveOneUnit(part.from, 1));\n        } else break;\n      } else {\n        if (target == bidiLeft(part)) {\n          part = bidi[--i];\n          target = part && bidiRight(part);\n        } else if (target == bidiRight(part)) {\n          part = bidi[++i];\n          target = part && bidiLeft(part);\n        } else break;\n      }\n    }\n\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr\";\n    function charType(code) {\n      if (code <= 0xff) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);\n      else if (0x700 <= code && code <= 0x8ac) return \"r\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len - 1 && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len - 1 ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push({from: start, to: i, level: 0});\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, {from: nstart, to: j, level: 2});\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift({from: 0, to: m[0].length, level: 0});\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push({from: len - m[0].length, to: len, level: 0});\n      }\n      if (order[0].level != lst(order).level)\n        order.push({from: len, to: len, level: order[0].level});\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"3.1 +\";\n\n  return CodeMirror;\n})();\n","// TODO actually recognize syntax of TypeScript constructs\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var jsonMode = parserConfig.json;\n  var isTS = parserConfig.typescript;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n    \n    var jsKeywords = {\n      \"if\": A, \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"delete\": C, \"throw\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\")\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"interface\"),\n        \"class\": kw(\"class\"),\n        \"extends\": kw(\"extends\"),\n        \"constructor\": kw(\"constructor\"),\n\n        // scope modifiers\n        \"public\": kw(\"public\"),\n        \"private\": kw(\"private\"),\n        \"protected\": kw(\"protected\"),\n        \"static\": kw(\"static\"),\n\n        \"super\": kw(\"super\"),\n\n        // types\n        \"string\": type, \"number\": type, \"bool\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function nextUntilUnescaped(stream, end) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped)\n        return false;\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return escaped;\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function jsTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\")\n      return chain(stream, state, jsTokenString(ch));\n    else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch))\n      return ret(ch);\n    else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    }      \n    else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    }\n    else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, jsTokenComment);\n      }\n      else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      }\n      else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" ||\n               /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        nextUntilUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimy]/); // 'y' is \"sticky\" option in Mozilla\n        return ret(\"regexp\", \"string-2\");\n      }\n      else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    }\n    else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    }\n    else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n    else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function jsTokenString(quote) {\n    return function(stream, state) {\n      if (!nextUntilUnescaped(stream, quote))\n        state.tokenize = jsTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function jsTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = jsTokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n  \n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state;\n      state.lexical = new JSLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type) {\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                      poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                         block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                        statement, poplex, popcontext);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n    if (type == \"operator\") return cont(expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(expression, \"]\"), poplex, maybeoperator);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n    \n  function maybeoperator(type, value) {\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(maybeoperator);\n      if (value == \"?\") return cont(expression, expect(\":\"), expression);\n      return cont(expression);\n    }\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n    if (type == \".\") return cont(property, maybeoperator);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperator, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type) {\n    if (type == \"variable\") cx.marked = \"property\";\n    else if (type == \"number\" || type == \"string\") cx.marked = type + \" property\";\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") return cont(what, proceed);\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      else return pass(what, proceed);\n    };\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (type == \":\") return cont(typedef);\n    return pass();\n  }\n  function typedef(type) {\n    if (type == \"variable\"){cx.marked = \"variable-3\"; return cont();}\n    return pass();\n  }\n  function vardef1(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return isTS ? cont(maybetype, vardef2) : cont(vardef2);\n    }\n    return pass();\n  }\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expression, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef1, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybein);\n    return cont(forspec2);\n  }\n  function formaybein(_type, value) {\n    if (value == \"in\") return cont(expression);\n    return cont(maybeoperator, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\") return cont(expression);\n    return cont(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type, value) {\n    if (type == \"variable\") {register(value); return isTS ? cont(maybetype) : cont();}\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      return {\n        tokenize: jsTokenBase,\n        lastType: null,\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        globalVars: parserConfig.globalVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == jsTokenComment) return CodeMirror.Pass;\n      if (state.tokenize != jsTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? 4 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \":{}\",\n\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n","/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\nCodeMirror.defineMode('coffeescript', function(conf) {\n    var ERRORCLASS = 'error';\n\n    function wordRegexp(words) {\n        return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n\n    var singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/%&|\\\\^~<>!\\?]\");\n    var singleDelimiters = new RegExp('^[\\\\(\\\\)\\\\[\\\\]\\\\{\\\\},:`=;\\\\.]');\n    var doubleOperators = new RegExp(\"^((\\->)|(\\=>)|(\\\\+\\\\+)|(\\\\+\\\\=)|(\\\\-\\\\-)|(\\\\-\\\\=)|(\\\\*\\\\*)|(\\\\*\\\\=)|(\\\\/\\\\/)|(\\\\/\\\\=)|(==)|(!=)|(<=)|(>=)|(<>)|(<<)|(>>)|(//))\");\n    var doubleDelimiters = new RegExp(\"^((\\\\.\\\\.)|(\\\\+=)|(\\\\-=)|(\\\\*=)|(%=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\n    var tripleDelimiters = new RegExp(\"^((\\\\.\\\\.\\\\.)|(//=)|(>>=)|(<<=)|(\\\\*\\\\*=))\");\n    var identifiers = new RegExp(\"^[_A-Za-z$][_A-Za-z$0-9]*\");\n    var properties = new RegExp(\"^(@|this\\.)[_A-Za-z$][_A-Za-z$0-9]*\");\n\n    var wordOperators = wordRegexp(['and', 'or', 'not',\n                                    'is', 'isnt', 'in',\n                                    'instanceof', 'typeof']);\n    var indentKeywords = ['for', 'while', 'loop', 'if', 'unless', 'else',\n                          'switch', 'try', 'catch', 'finally', 'class'];\n    var commonKeywords = ['break', 'by', 'continue', 'debugger', 'delete',\n                          'do', 'in', 'of', 'new', 'return', 'then',\n                          'this', 'throw', 'when', 'until'];\n\n    var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n    indentKeywords = wordRegexp(indentKeywords);\n\n\n    var stringPrefixes = new RegExp(\"^('{3}|\\\"{3}|['\\\"])\");\n    var regexPrefixes = new RegExp(\"^(/{3}|/)\");\n    var commonConstants = ['Infinity', 'NaN', 'undefined', 'null', 'true', 'false', 'on', 'off', 'yes', 'no'];\n    var constants = wordRegexp(commonConstants);\n\n    // Tokenizers\n    function tokenBase(stream, state) {\n        // Handle scope changes\n        if (stream.sol()) {\n            var scopeOffset = state.scopes[0].offset;\n            if (stream.eatSpace()) {\n                var lineOffset = stream.indentation();\n                if (lineOffset > scopeOffset) {\n                    return 'indent';\n                } else if (lineOffset < scopeOffset) {\n                    return 'dedent';\n                }\n                return null;\n            } else {\n                if (scopeOffset > 0) {\n                    dedent(stream, state);\n                }\n            }\n        }\n        if (stream.eatSpace()) {\n            return null;\n        }\n\n        var ch = stream.peek();\n\n        // Handle docco title comment (single line)\n        if (stream.match(\"####\")) {\n            stream.skipToEnd();\n            return 'comment';\n        }\n\n        // Handle multi line comments\n        if (stream.match(\"###\")) {\n            state.tokenize = longComment;\n            return state.tokenize(stream, state);\n        }\n\n        // Single line comment\n        if (ch === '#') {\n            stream.skipToEnd();\n            return 'comment';\n        }\n\n        // Handle number literals\n        if (stream.match(/^-?[0-9\\.]/, false)) {\n            var floatLiteral = false;\n            // Floats\n            if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n              floatLiteral = true;\n            }\n            if (stream.match(/^-?\\d+\\.\\d*/)) {\n              floatLiteral = true;\n            }\n            if (stream.match(/^-?\\.\\d+/)) {\n              floatLiteral = true;\n            }\n\n            if (floatLiteral) {\n                // prevent from getting extra . on 1..\n                if (stream.peek() == \".\"){\n                    stream.backUp(1);\n                }\n                return 'number';\n            }\n            // Integers\n            var intLiteral = false;\n            // Hex\n            if (stream.match(/^-?0x[0-9a-f]+/i)) {\n              intLiteral = true;\n            }\n            // Decimal\n            if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n                intLiteral = true;\n            }\n            // Zero by itself with no other piece of number.\n            if (stream.match(/^-?0(?![\\dx])/i)) {\n              intLiteral = true;\n            }\n            if (intLiteral) {\n                return 'number';\n            }\n        }\n\n        // Handle strings\n        if (stream.match(stringPrefixes)) {\n            state.tokenize = tokenFactory(stream.current(), 'string');\n            return state.tokenize(stream, state);\n        }\n        // Handle regex literals\n        if (stream.match(regexPrefixes)) {\n            if (stream.current() != '/' || stream.match(/^.*\\//, false)) { // prevent highlight of division\n                state.tokenize = tokenFactory(stream.current(), 'string-2');\n                return state.tokenize(stream, state);\n            } else {\n                stream.backUp(1);\n            }\n        }\n\n        // Handle operators and delimiters\n        if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {\n            return 'punctuation';\n        }\n        if (stream.match(doubleOperators)\n            || stream.match(singleOperators)\n            || stream.match(wordOperators)) {\n            return 'operator';\n        }\n        if (stream.match(singleDelimiters)) {\n            return 'punctuation';\n        }\n\n        if (stream.match(constants)) {\n            return 'atom';\n        }\n\n        if (stream.match(keywords)) {\n            return 'keyword';\n        }\n\n        if (stream.match(identifiers)) {\n            return 'variable';\n        }\n\n        if (stream.match(properties)) {\n            return 'property';\n        }\n\n        // Handle non-detected items\n        stream.next();\n        return ERRORCLASS;\n    }\n\n    function tokenFactory(delimiter, outclass) {\n        var singleline = delimiter.length == 1;\n        return function(stream, state) {\n            while (!stream.eol()) {\n                stream.eatWhile(/[^'\"\\/\\\\]/);\n                if (stream.eat('\\\\')) {\n                    stream.next();\n                    if (singleline && stream.eol()) {\n                        return outclass;\n                    }\n                } else if (stream.match(delimiter)) {\n                    state.tokenize = tokenBase;\n                    return outclass;\n                } else {\n                    stream.eat(/['\"\\/]/);\n                }\n            }\n            if (singleline) {\n                if (conf.mode.singleLineStringErrors) {\n                    outclass = ERRORCLASS;\n                } else {\n                    state.tokenize = tokenBase;\n                }\n            }\n            return outclass;\n        };\n    }\n\n    function longComment(stream, state) {\n        while (!stream.eol()) {\n            stream.eatWhile(/[^#]/);\n            if (stream.match(\"###\")) {\n                state.tokenize = tokenBase;\n                break;\n            }\n            stream.eatWhile(\"#\");\n        }\n        return \"comment\";\n    }\n\n    function indent(stream, state, type) {\n        type = type || 'coffee';\n        var indentUnit = 0;\n        if (type === 'coffee') {\n            for (var i = 0; i < state.scopes.length; i++) {\n                if (state.scopes[i].type === 'coffee') {\n                    indentUnit = state.scopes[i].offset + conf.indentUnit;\n                    break;\n                }\n            }\n        } else {\n            indentUnit = stream.column() + stream.current().length;\n        }\n        state.scopes.unshift({\n            offset: indentUnit,\n            type: type\n        });\n    }\n\n    function dedent(stream, state) {\n        if (state.scopes.length == 1) return;\n        if (state.scopes[0].type === 'coffee') {\n            var _indent = stream.indentation();\n            var _indent_index = -1;\n            for (var i = 0; i < state.scopes.length; ++i) {\n                if (_indent === state.scopes[i].offset) {\n                    _indent_index = i;\n                    break;\n                }\n            }\n            if (_indent_index === -1) {\n                return true;\n            }\n            while (state.scopes[0].offset !== _indent) {\n                state.scopes.shift();\n            }\n            return false;\n        } else {\n            state.scopes.shift();\n            return false;\n        }\n    }\n\n    function tokenLexer(stream, state) {\n        var style = state.tokenize(stream, state);\n        var current = stream.current();\n\n        // Handle '.' connected identifiers\n        if (current === '.') {\n            style = state.tokenize(stream, state);\n            current = stream.current();\n            if (/^\\.[\\w$]+$/.test(current)) {\n                return 'variable';\n            } else {\n                return ERRORCLASS;\n            }\n        }\n\n        // Handle scope changes.\n        if (current === 'return') {\n            state.dedent += 1;\n        }\n        if (((current === '->' || current === '=>') &&\n                  !state.lambda &&\n                  state.scopes[0].type == 'coffee' &&\n                  stream.peek() === '')\n               || style === 'indent') {\n            indent(stream, state);\n        }\n        var delimiter_index = '[({'.indexOf(current);\n        if (delimiter_index !== -1) {\n            indent(stream, state, '])}'.slice(delimiter_index, delimiter_index+1));\n        }\n        if (indentKeywords.exec(current)){\n            indent(stream, state);\n        }\n        if (current == 'then'){\n            dedent(stream, state);\n        }\n\n\n        if (style === 'dedent') {\n            if (dedent(stream, state)) {\n                return ERRORCLASS;\n            }\n        }\n        delimiter_index = '])}'.indexOf(current);\n        if (delimiter_index !== -1) {\n            if (dedent(stream, state)) {\n                return ERRORCLASS;\n            }\n        }\n        if (state.dedent > 0 && stream.eol() && state.scopes[0].type == 'coffee') {\n            if (state.scopes.length > 1) state.scopes.shift();\n            state.dedent -= 1;\n        }\n\n        return style;\n    }\n\n    var external = {\n        startState: function(basecolumn) {\n            return {\n              tokenize: tokenBase,\n              scopes: [{offset:basecolumn || 0, type:'coffee'}],\n              lastToken: null,\n              lambda: false,\n              dedent: 0\n          };\n        },\n\n        token: function(stream, state) {\n            var style = tokenLexer(stream, state);\n\n            state.lastToken = {style:style, content: stream.current()};\n\n            if (stream.eol() && stream.lambda) {\n                state.lambda = false;\n            }\n\n            return style;\n        },\n\n        indent: function(state) {\n            if (state.tokenize != tokenBase) {\n                return 0;\n            }\n\n            return state.scopes[0].offset;\n        },\n\n        lineComment: \"#\",\n        fold: \"indent\"\n    };\n    return external;\n});\n\nCodeMirror.defineMIME('text/x-coffeescript', 'coffeescript');\n","Template.__define__(\"logs_bootstrap\",Package.handlebars.Handlebars.json_ast_to_func([\"<div class=\\\"\",[\"{\",[[0,\"theme\"]]],\"\\\" id=\\\"lb_id_containing_box\\\"><!-- theming support -->\\n        <div id=\\\"id_logs_bootstrap\\\" \",[\"#\",[[0,\"if\"],[0,\"isDynamic\"]],[\"class=\\\"observatory_panel \",[\"{\",[[0,\"height\"]]],\"\\\"\"],[\"class=\\\"observatory_panel_static  \",[\"#\",[[0,\"if\"],[0,\"isHidden\"]],[\"lb_hidden\"]],\"\\\"\"]],\">\\n              \",[\"#\",[[0,\"if\"],[0,\"fullFeatured\"]],[\"\\n              <ul class=\\\"nav-tabs\\\" id=\\\"lb_main_tab\\\">\\n                    <li><a href=\\\"#\\\" data-target=\\\"observatoryjsLogsTab\\\" id=\\\"id_logs_tab_btn\\\">Logs</a></li>\\n                    <li><a href=\\\"#\\\" data-target=\\\"observatoryjsInternalsTab\\\" id=\\\"id_app_tab_btn\\\">Templates Inspection</a></li>\\n                    <!-- <li><a href=\\\"#id_templates_tab\\\" id=\\\"id_templates_tab_btn\\\">Tests</a></li> -->\\n                    <!-- <li><a href=\\\"#\\\" data-target=\\\"observatoryjsLogsSimple\\\" id=\\\"id_export_tab_btn\\\">Export</a></li> -->\\n                    <li><a href=\\\"#\\\" data-target=\\\"observatoryjsHelpTab\\\" id=\\\"id_help_tab_btn\\\">Help</a></li>\\n                    <li><button class=\\\"lb_btn pull-right\\\" type=\\\"button\\\" id=\\\"lb_btn_change_theme\\\">change theme</button></li>\\n                   <!-- <li><button class=\\\"btn btn-mini btn-info\\\" type=\\\"button\\\" id=\\\"lb_btn_switch_dynamic\\\">toggle full page</button></li> -->\\n                    <li><button class=\\\"lb_btn pull-right\\\" id=\\\"lb_btn_clear_logs\\\" type=\\\"button\\\" disabled>clear logs</button></li>\\n                  <div id=\\\"lb_status_line\\\" class=\\\"pull-right\\\">\\n                      \",[\"#\",[[0,\"with\"],[0,\"blGetSession\"],\"observatoryjs.ConnectionStatus\"],[\"\\n                      \",[\"#\",[[0,\"if\"],[0,\"connected\"]],[\"\\n                      <span style=\\\"color: #2c2;\\\">connected</span>\\n                      \"],[\"\\n                      <span style=\\\"color: #c22;\\\">disconnected:</span>\",[\"{\",[[0,\"reason\"]]],\" (\",[\"{\",[[0,\"retryCount\"]]],\")\\n                      | status: \",[\"{\",[[0,\"status\"]]],\"\\n                      \"]],\"\\n                      \"]],\"\\n                  </div>\\n              </ul>\\n               \"],[\"\\n                <div id=\\\"lb_status_line\\\">\\n                    \",[\"#\",[[0,\"with\"],[0,\"blGetSession\"],\"observatoryjs.ConnectionStatus\"],[\"\\n                    \",[\"#\",[[0,\"if\"],[0,\"connected\"]],[\"\\n                    <span style=\\\"color: #2c2;\\\">connected</span>\\n                    \"],[\"\\n                    <span style=\\\"color: #c22;\\\">disconnected:</span>\",[\"{\",[[0,\"reason\"]]],\" (\",[\"{\",[[0,\"retryCount\"]]],\")\\n                    | status: \",[\"{\",[[0,\"status\"]]],\"\\n                    \"]],\"\\n                    \"]],\"\\n                </div>\\n              \"]],\"\\n\\n        \",[\"!\",[[0,\"observatoryjsRenderCurrent\"]]],\"\\n        </div>\\n        <a class=\\\"observatory_trigger\\\" href=\\\"#\\\" id=\\\"btn_toggle_logs\\\">O!</a>\\n        <a class=\\\"observatory_trigger\\\" href=\\\"#\\\" id=\\\"btn_toggle_session\\\">S!</a>\\n    </div>\\n\\n        \",[\">\",\"observatoryjsSession\"]]));\nTemplate.__define__(\"observatoryjsLogsTab\",Package.handlebars.Handlebars.json_ast_to_func([\"<!-- logs tab tab -->\\n    <div class=\\\"tab-pane\\\" style=\\\"height: 100%;\\\" id=\\\"observatoryjsLogsTab\\\" >\\n\\n        <div class=\\\"lb_scrollable\\\">\\n            <table class=\\\"table table-condensed lb_table-striped\\\">\\n                <thead>\\n                <tr class=\\\"lb_header\\\">\\n                    <th id=\\\"lbh_timestamp\\\" class=\\\"lb_timestamp\\\"><a href=\\\"#\\\">timestamp</a></th>\\n                    <th id=\\\"lbh_user\\\" class=\\\"lb_user\\\"><a href=\\\"#\\\">user</a></th>\\n                    <th id=\\\"lbh_source\\\" class=\\\"lb_server\\\"><a href=\\\"#\\\">src</a></th>\\n                    <th id=\\\"lbh_module\\\" class=\\\"lb_module\\\"><a href=\\\"#\\\">module</a></th>\\n                    <th id=\\\"lbh_severity\\\" class=\\\"lb_loglevel\\\"><a href=\\\"#\\\">severity</a></th>\\n                    <th><a href=\\\"#\\\">message</a></th>\\n                </tr>\\n                </thead>\\n                <tbody>\\n                \",[\"#\",[[0,\"each\"],[0,\"log_messages\"]],[\"\\n                <tr class=\\\"\",[\"{\",[[0,\"lb_loglevel_row_decoration\"]]],\" no_border\\\">\\n                    <td class=\\\"lb_timestamp\\\">\",[\"{\",[[0,\"format_timestamp\"],[0,\"timestamp\"]]],\"</td>\\n                    <td class=\\\"lb_user\\\">\",[\"{\",[[0,\"getUser\"],[0]]],\"</td>\\n                    \",[\"#\",[[0,\"if\"],[0,\"isServer\"]],[\"\\n                    <td class=\\\"lb_server\\\"><span class=\\\"label label-inverse\\\">server</span></td>\\n                    \"],[\"\\n                    <td class=\\\"lb_client\\\"><span class=\\\"label lb_test_label\\\">client</span></td>\\n                    \"]],\"\\n                    <td class=\\\"lb_module\\\">\\n                        \",[\"#\",[[0,\"if\"],[0,\"module\"]],[\"\\n                        <span class=\\\"label label-primary\\\">\",[\"{\",[[0,\"module\"]]],\"</span>\\n                        \"]],\"\\n                    </td>\\n                    <td class=\\\"lb_loglevel\\\"><span class=\\\"label \",[\"{\",[[0,\"lb_loglevel_decoration\"]]],\"\\\">\",[\"{\",[[0,\"loglevel_names\"],[0,\"severity\"]]],\"</span></td>\\n                    <td class=\\\"lb_message\\\"><pre class=\\\" \",[\"{\",[[0,\"lb_loglevel_msg_decoration\"]]],\"\\\">\",[\"{\",[[0,\"textMessage\"]]],\"</pre></td>\\n                    \"]],\"\\n                </tbody>\\n            </table>\\n        </div>\\n\\n\\n    </div>\"]));\nTemplate.__define__(\"observatoryjsInternalsTab\",Package.handlebars.Handlebars.json_ast_to_func([\"<!-- templates & events tab -->\\n    <div class=\\\"tab-pane\\\" style=\\\"height: 100%;\\\" >\\n\\n        <!-- application internals tab -->\\n        <div class=\\\"lb_scrollable\\\" id=\\\"id_templates_div\\\">\\n            <select id=\\\"selTemplateNames\\\">\\n                \",[\"#\",[[0,\"each\"],[0,\"templates\"]],[\"\\n                <option value=\\\"\",[\"{\",[[0]]],\"\\\">\",[\"{\",[[0]]],\"</option>\\n                \"]],\"\\n            </select>\\n\\n            <table>\\n                <tbody>\\n                <tr>\\n                    <th>main callbacks</th>\\n                </tr>\\n                <tr>\\n                    <td><a href=\\\"#\\\" class=\\\"lb_template_events_list\\\" templateName=\\\"\",[\"{\",[[0,\"selectedTemplateName\"]]],\"\\\" methodName=\\\"created\\\">created</a></td>\\n                </tr>\\n                <tr>\\n                    <td><a href=\\\"#\\\" class=\\\"lb_template_events_list\\\" templateName=\\\"\",[\"{\",[[0,\"selectedTemplateName\"]]],\"\\\" methodName=\\\"rendered\\\">rendered</a></td>\\n                </tr>\\n                <tr>\\n                    <td><a href=\\\"#\\\" class=\\\"lb_template_events_list\\\" templateName=\\\"\",[\"{\",[[0,\"selectedTemplateName\"]]],\"\\\" methodName=\\\"destroyed\\\">destroyed</a></td>\\n                </tr>\\n                <tr>\\n                    <th>events</th>\\n                </tr>\\n                <tr>\\n                    <td>\\n                        \",[\"#\",[[0,\"each\"],[0,\"currentTemplateEvents\"]],[\"\\n                        <a href=\\\"#\\\" class=\\\"lb_template_events_list\\\" templateName=\\\"\",[\"{\",[[0,\"selectedTemplateName\"]]],\"\\\" methodName=\\\"\",[\"{\",[[0]]],\"\\\">\",[\"{\",[[0]]],\"</a><br/>\\n                        \"]],\"\\n                    </td>\\n                </tr>\\n                <tr>\\n                    <th>helpers</th>\\n                </tr>\\n                <tr>\\n                    <td colspan=\\\"3\\\">\\n                        \",[\"#\",[[0,\"each\"],[0,\"currentTemplateHelpers\"]],[\"\\n                        <a href=\\\"#\\\" class=\\\"lb_template_events_list\\\" templateName=\\\"\",[\"{\",[[0,\"selectedTemplateName\"]]],\"\\\" methodName=\\\"\",[\"{\",[[0]]],\"\\\">\",[\"{\",[[0]]],\"</a><br/>\\n                        \"]],\"\\n                    </td>\\n                </tr>\\n                </tbody>\\n            </table>\\n            <div>\\n                \",[\"#\",[[0,\"each\"],[0,\"blGetSession\"],\"observatoryjs.CurrentSubscriptions\"],[\"\\n                \",[\"{\",[[0,\"name\"]]],\": \",[\"{\",[[0,\"inactive\"]]],\": \",[\"{\",[[0,\"ready\"]]],\" <br/>\\n                \"]],\"\\n            </div>\\n        </div>\\n\\n        <div id=\\\"lb_code_console\\\">\\n        </div>\\n    </div>\"]));\nTemplate.__define__(\"observatoryjsSession\",Package.handlebars.Handlebars.json_ast_to_func([\"<div class=\\\"\",[\"{\",[[0,\"theme\"]]],\"\\\">\\n    <div id=\\\"lb_session_popup\\\" class=\\\"\",[\"{\",[[0,\"sessionWidth\"]]],\"\\\">\\n        <table class=\\\"table table-condensed\\\" id=\\\"tableSession\\\" style=\\\"margin: 6px 6px 6px 6px\\\">\\n            <thead>\\n            <tr><th>Session</th></tr>\\n            </thead>\\n\\n            <tbody>\\n            \",[\"#\",[[0,\"each\"],[0,\"session_keys\"]],[\"\\n            <tr class=\\\"sessionKey\\\" style=\\\"padding: 0; margin: 0\\\">\\n                <th class=\\\"\\\" style=\\\"padding: 0; margin: 0\\\">\",[\"{\",[[0,\"key\"]]],\":</th>\\n            </tr>\\n            <tr class=\\\"\\\" style=\\\"padding: 0; margin: 0\\\">\\n                <td class=\\\"\\\" style=\\\"padding: 0; margin: 0\\\">\",[\"{\",[[0,\"value\"]]],\"</td>\\n            </tr>\\n            \"]],\"\\n            </tbody>\\n        </table>\\n\\n    </div>\\n    </div>\"]));\nTemplate.__define__(\"observatoryjsHelpTab\",Package.handlebars.Handlebars.json_ast_to_func([\"<!-- help tab -->\\n    <div id=\\\"id_help_tab\\\" class=\\\"tab-pane\\\" style=\\\"height:100%;\\\">\\n        <div class=\\\"lb_scrollable\\\">\\n            <p>Please see <a href=\\\"http://observatoryjs.com/\\\">Observatory web page</a> for the complete documentation. Since \\n                <span class=\\\"label label-success\\\">version 0.3.0</span> we have shifted main development focus to Observatory: Vega\\n                - cloud-based easy to use logging, monitoring and application management for your Meteor apps. \\n                <a href=\\\"http://observatoryjs.com/\\\">Check it out!</a>\\n            </p>\\n            <p>\\n                Observatory panel is controlled by pressing the \\\"O!\\\" button in the bottom-left corner of the page or \\\"ctrl + ~\\\" key:\\n                you can have it small, medium,\\n                large or completely turned off. By moving between tabs you can analyze logs (updated live), your application's templates with\\n                events, as well as monitor other internals (currently, Session state, more to come). Everything is scrollable, logs are\\n                sortable (just click on the column name).</p>\\n            <p>\\n                Session panel is controlled by clicking \\\"S!\\\" button or pressing \\\"~\\\" key.\\n            </p>\\n            <p>\\n                We love to hear your feedback: please <a href=\\\"https://github.com/jhoxray/observatory\\\">submit your ideas,\\n                questions, suggestions on Github</a> as issues!\\n            </p>\\n            <h5>Logging in a nutshell:</h5>\\n            <p>\\n                Simply call <code>tb = Observatory.getToolbox()</code> once in your app's common\\n                code (that gets executed on both client and server) and then call the following obvious methods:\\n                <code>tb.fatal(\\\"...\\\"), error, warn, info, verbose, debug</code>. Your logs will be updated automatically in the \\\"Log\\\" tab.\\n                There's much, much more - <a href=\\\"http://observatoryjs.com/#docInstallation\\\">read the docs</a> for automagical logging,\\n                monitoring, profiling and app management features!\\n            </p>\\n        </div>\\n\\n    </div>\"]));\nTemplate.__define__(\"observatoryjsLogsSimple\",Package.handlebars.Handlebars.json_ast_to_func([[\"#\",[[0,\"each\"],[0,\"log_messages\"]],[\"\\n\",[\"{\",[[0,\"full_message\"]]],\"<br/>\\n\"]]]));\n","_tlog = TLog.getLogger()\n\nMeteor.startup ->\n  Handlebars.registerHelper \"blGetSession\", (name) ->\n    Session.get name\n\n\n############################################################################################################\n# EVENTS\n# Main Observatory Panel Template\n############################################################################################################\n#Session.get \"bl_default_panel\" - \"hidden\" or \"half\"\nTemplate.logs_bootstrap.events\n  #switching main tabs in the panel\n  \"click #lb_main_tab\": (evt)->\n    tg = evt.target.getAttribute(\"data-target\")\n    #TLog.getLogger().warn(\"Clicked on \" + tg)\n    Session.set \"observatoryjs-currentRender\", tg if tg\n\n\n  #switching themes\n  \"click #lb_btn_change_theme\": ->\n    if Session.get(\"bl_current_theme\") is \"lb_theme_dark\"\n      Session.set(\"bl_current_theme\", \"lb_theme_light\")\n      Session.set(\"bl_current_codemirror_theme\", \"solarized\")\n    else\n      Session.set(\"bl_current_theme\", \"lb_theme_dark\")\n      Session.set(\"bl_current_codemirror_theme\", \"ambiance\")\n\n  #clearing the logs - DANGEROUS and insecure\n  #TODO: once auth arrives, make sure it's properly protected\n  \"click #lb_btn_clear_logs\": ->\n    #alert \"This is a demo app so no logs are in fact cleared! Install in your project and it will work properly :)\"\n    TLog._clear()\n\n  \"click #btn_toggle_session\": ->\n    w = Session.get \"bl_current_session_width\"\n    switch w\n      when \"lb_invisible\"\n        Session.set \"bl_current_session_width\", \"lb_width25\"\n      when \"lb_width25\"\n        Session.set \"bl_current_session_width\", \"lb_width50\"\n      when \"lb_width50\"\n        Session.set \"bl_current_session_width\", \"lb_invisible\"\n\n\n  #Switching modes of the observatory panel\n  \"click #btn_toggle_logs\": (evt, tmpl)->\n    Template.logs_bootstrap.toggleLogs()\n\n############################################################################################################\n# HELPERS\n# Main Observatory Panel Template\n############################################################################################################\nTemplate.logs_bootstrap.helpers\n  observatoryjsRenderCurrent: ->\n    tmpl = Session.get \"observatoryjs-currentRender\"\n    if Template[tmpl]\n      new Handlebars.SafeString(Template[tmpl]())\n    else\n      new Handlebars.SafeString(Template[\"observatoryjsLogsTab\"]())\n\n  isHidden: ->\n    return !(Session.get \"bl_is_visible\")\n\n  isDynamic: ->\n    return Session.get \"bl_is_dynamic\"\n  #helper to display either full panel or trimmed down version (e.g., just the logs)\n  fullFeatured: ->\n    Session.get(\"bl_full_featured_panel\")\n\n  #returning current theme class\n  theme: ->\n    Session.get(\"bl_current_theme\")\n  #\"lb_theme_light\"\n\n  #helper returning the class that corresponds to needed height of the panel\n  height: ->\n    Session.get(\"bl_panel_height_class\")\n\n############################################################################################################\n# OTHER\n# Main Observatory Panel Template\n############################################################################################################\n#Twitter Bootstrap formatted template\n_.extend Template.logs_bootstrap,\n  toggleLogs: ->\n    switch Session.get(\"bl_panel_height_class\")\n      when \"height50\"\n        Session.set \"bl_is_dynamic\", false\n        Session.set(\"bl_panel_height_class\",\"height90\")\n        Session.set(\"bl_full_featured_panel\",true)\n\n      when \"height90\"\n        Session.set(\"bl_panel_height_class\",\"\")\n        $(\"#id_logs_bootstrap\").hide(\"fast\")\n        Session.set \"bl_is_visible\", false\n\n      when \"height25\"\n        Session.set(\"bl_panel_height_class\",\"height50\")\n        Session.set(\"bl_full_featured_panel\",true)\n      when \"\"\n        Session.set \"bl_is_dynamic\", true\n        Session.set(\"bl_panel_height_class\",\"height25\")\n        Session.set(\"bl_full_featured_panel\",false)\n        Session.set \"bl_is_visible\", true\n        $(\"#id_logs_bootstrap\").removeClass(\"lb_hidden\")\n        $(\"#id_logs_bootstrap\").show(\"slow\")\n\n\n    #console.log \"Setting margin-bottom of the last element to #{tt} px\"\n    #console.dir $(\"body\").children().last()\n    Deps.flush()\n\n    if Session.equals \"bl_is_visible\", true\n      tt = $('#id_logs_bootstrap').outerHeight()\n      #console.dir \"Current height is #{tt}\"\n      $(\"body\").children().last().css('margin-bottom', tt + 20)\n    else\n      $(\"body\").children().last().css('margin-bottom', 0) #Template.logs_bootstrap.originalMainMargin)\n\n\n\n  destroyed: ->\n    #Meteor.clearInterval @_handle\n\n   #setting initial sort order for the logs\n  created: ->\n    #Template.logs_bootstrap.originalMainMargin = $(\"body\").children().last().css('margin-bottom')\n    #console.log \"Remembering margin as #{Template.logs_bootstrap.originalMainMargin}\"\n    def = Session.get \"bl_default_panel\"\n    if def? then Template.logs_bootstrap.setDefault def else Template.logs_bootstrap.setDefault \"hidden\"\n    Session.setDefault \"bl_current_codemirror_theme\", \"ambiance\"\n    Session.setDefault \"bl_current_session_width\", \"lb_invisible\"\n    #Session.setDefault \"observatoryjs-currentRender\", \"observatoryjsLogsTab\"\n\n    # checking connection status\n    Deps.autorun ->\n      #_tlog.debug \"Calling function that polls connection status (supposedly)...\"\n      Session.set \"observatoryjs.ConnectionStatus\", Meteor.status()\n\n\n\n  rendered: ->\n    # setting whatever last elements bottom marging is to manipulate in observatory panel size changes\n    Session.setDefault \"observatoryjs-currentRender\", \"observatoryjsLogsTab\"\n    # handling key presses to toggle session and the panel\n    $('body').on 'keydown', (evt)->\n      #console.dir evt\n      evt.stopImmediatePropagation()\n      #console.log 'key pressed: ' + evt.which\n      if evt.which == 192 and not $(evt.target).is \"input\"\n        if evt.ctrlKey\n          Template.logs_bootstrap.toggleLogs()\n        else\n          w = Session.get \"bl_current_session_width\"\n          switch w\n            when \"lb_invisible\"\n              Session.set \"bl_current_session_width\", \"lb_width25\"\n            when \"lb_width25\"\n              Session.set \"bl_current_session_width\", \"lb_width50\"\n            when \"lb_width50\"\n              Session.set \"bl_current_session_width\", \"lb_invisible\"\n\n\n\n\n\n\n  # setting default panel status - hidden or 50% of the screen\n  setDefault: (option)->\n    switch option\n      when \"hidden\"\n        Session.setDefault \"bl_sort_desc\", true\n        Session.setDefault \"bl_sort_by\",\"timestamp\"\n        Session.setDefault \"bl_full_featured_panel\",false\n        Session.setDefault \"bl_panel_height_class\",\"\"\n        Session.setDefault \"bl_current_theme\", \"lb_theme_dark\"\n        Session.setDefault \"bl_is_dynamic\", false  # defaults for hidden. for showing: change height_class to height25, dynamic & visible - to true\n        Session.setDefault \"bl_is_visible\", false\n      when \"half\"\n        Session.setDefault \"bl_sort_desc\", true\n        Session.setDefault \"bl_sort_by\",\"timestamp\"\n        Session.setDefault \"bl_full_featured_panel\",false\n        Session.setDefault \"bl_panel_height_class\",\"height25\"\n        Session.setDefault \"bl_current_theme\", \"lb_theme_dark\"\n        Session.setDefault \"bl_is_dynamic\", true\n        Session.setDefault \"bl_is_visible\", true\n\n\n\n######################################################################################################################\n# Template handling application internals\n# EVENTS\n######################################################################################################################\nTemplate.observatoryjsInternalsTab.events\n  \"mouseleave .lb_template_events_list\": (evt, templ)->\n    selTmpl = Template[evt.target.getAttribute(\"templateName\")]\n    return if not selTmpl?\n    method = evt.target.getAttribute(\"methodName\")\n    func = selTmpl._tmpl_data?.events?[method]\n    if func\n      events = method.split ','\n      for e in events\n        k = e.split ' '\n        $(k[1]).removeClass \"lb_highlight_element\"\n\n  #showing the source code for the chosen event\n  \"mouseenter .lb_template_events_list\": (evt, templ)->\n    selTmpl = Template[evt.target.getAttribute(\"templateName\")]\n    return if not selTmpl?\n    method = evt.target.getAttribute(\"methodName\")\n    #console.log \"Entered: \" + evt.target.getAttribute(\"templateName\") + \" w/ method: \" + method\n    if method in [\"created\",\"rendered\",\"destroyed\"]\n      func = selTmpl[method]\n      strFunc = \"// Template.\" + evt.target.getAttribute(\"templateName\") + \".\" + method + \":\\n\" + func\n      #_tlog.debug \"Method is a key callback:\\n\" + strFunc\n    else\n      func = selTmpl._tmpl_data.events?[method]\n      if func\n        strFunc = \"// EVENT: \" + method + \":\\n\" + func\n        #_tlog.debug \"Method is an event:\\n\" + strFunc\n        events = method.split ','\n        for e in events\n          k = e.split ' '\n          $(k[1]).addClass \"lb_highlight_element\"\n      else\n        func = selTmpl._tmpl_data.helpers?[method]\n        strFunc = \"// HELPER: \" + method + \":\\n\" + func\n        #_tlog.debug \"Method is a helper:\\n\" + strFunc\n    #console.dir templ\n    #console.log \"Setting codemirror field with \" + strFunc\n    templ.myCodeMirror.setValue strFunc\n    #templ.myCodeMirror.refresh()\n    #console.dir templ.myCodeMirror.doc.children\n    #$(\"#lb_code_console\").html strFunc\n\n    #console.log func.toString()\n\n  \"change #selTemplateNames\": (evt)->\n    _tlog.debug $(evt.target).val()\n    Session.set \"bl_selected_template_name\", $(evt.target).val()\n\n\n######################################################################################################################\n# Template handling application internals\n# HELPERS\n######################################################################################################################\nTemplate.observatoryjsInternalsTab.helpers\n  selectedTemplateName: ->\n    Session.get \"bl_selected_template_name\"\n\n  #Templates\n  templates: ->\n    rt = Inspect.methods(Template)\n    rt.sort()\n    rt\n\n  currentTemplateEvents: ->\n    Template.observatoryjsInternalsTab.getMethodMap \"events\",Session.get \"bl_selected_template_name\"\n\n  currentTemplateHelpers: ->\n    Template.observatoryjsInternalsTab.getMethodMap \"helpers\",Session.get \"bl_selected_template_name\"\n\n\n######################################################################################################################\n# Template handling application internals\n# OTHER\n######################################################################################################################\n_.extend Template.observatoryjsInternalsTab,\n  destroyed: ->\n    #Meteor.clearInterval @_handle\n\n  created: ->\n    # monitoring state of collections and subscriptions\n    # TODO: style it\n    # TODO: create collection monitoring area\n    # TODO: ok, we are moving it from here anyway, so commenting out. It belongs to\n    # TODO: separately thought out monitoring client module\n    ###\n    @_handle = Meteor.setInterval =>\n      @_subscriptions = (v for k,v of TLog._global_logs._manager?._subscriptions)\n      @_collections = Meteor._LocalCollectionDriver.collections\n      Session.set \"observatoryjs.CurrentSubscriptions\", @_subscriptions\n    , 5000\n    ###\n\n  rendered: ->\n    $(\"#selTemplateNames\").val Session.get \"bl_selected_template_name\"\n    Session.set \"bl_selected_template_name\", $(\"#selTemplateNames\").val()\n    #tmp = $(\"#selTemplateNames\").val()\n    #console.log tmp + \" and \" + Session.get \"bl_selected_template_name\"\n    @myCodeMirror = null\n    if not @myCodeMirror?\n      @myCodeMirror = CodeMirror document.getElementById(\"lb_code_console\"),\n        value: \"\"\n        mode:  \"javascript\"\n        theme: Session.get \"bl_current_codemirror_theme\"\n        readOnly: true\n      #Meteor.flush()\n\n  getMethodMap: (type, tmpl)->\n    rt = []\n    rt.push tt for tt of Template[tmpl]?._tmpl_data?[type]\n    rt.sort()\n\n\n######################################################################################################################\n# Template handling Session\n# HELPERS\n######################################################################################################################\nTemplate.observatoryjsSession.helpers\n  sessionWidth: ->\n    Session.get(\"bl_current_session_width\")\n  #returning current theme class\n  theme: ->\n    Session.get(\"bl_current_theme\")\n  #Filling Session keys\n  session_keys: ->\n    rt = []\n    rt.push {\"key\": key, \"value\": JSON.stringify Session.get(key)} for key of Session.keys\n    rt.sort()\n\n\n\n######################################################################################################################\n# Template handling log display\n# EVENTS\n######################################################################################################################\nTemplate.observatoryjsLogsTab.events\n  #Sort functions go below;\n  #TODO: put them all in one and optimize\n  \"click #lbh_timestamp\": ->\n    #TLog._getLogger().verbose(\"clicked on timestamp\")\n    Session.set(\"bl_sort_by\",\"timestamp\")\n    sort_desc = Session.get(\"bl_sort_desc\")\n    if sort_desc then Session.set(\"bl_sort_desc\",false) else Session.set(\"bl_sort_desc\",true)\n\n  \"click #lbh_module\": ->\n    #TLog._getLogger().verbose(\"clicked on severity\")\n    Session.set(\"bl_sort_by\",\"module\")\n    sort_desc = Session.get(\"bl_sort_desc\")\n    if sort_desc then Session.set(\"bl_sort_desc\",false) else Session.set(\"bl_sort_desc\",true)\n\n  \"click #lbh_severity\": ->\n    #TLog._getLogger().verbose(\"clicked on severity\")\n    Session.set(\"bl_sort_by\",\"severity\")\n    sort_desc = Session.get(\"bl_sort_desc\")\n    if sort_desc then Session.set(\"bl_sort_desc\",false) else Session.set(\"bl_sort_desc\",true)\n\n  \"click #lbh_source\": ->\n    #TLog._getLogger().verbose(\"clicked on source\")\n    Session.set(\"bl_sort_by\",\"source\")\n    sort_desc = Session.get(\"bl_sort_desc\")\n    if sort_desc then Session.set(\"bl_sort_desc\",false) else Session.set(\"bl_sort_desc\",true)\n\n######################################################################################################################\n# Template handling log display\n# HELPERS\n######################################################################################################################\nTemplate.observatoryjsLogsTab.helpers\n#filling relevant log messages based on the current sort parameters\n  log_messages: ->\n    sort_order = if Session.get(\"bl_sort_desc\") then -1 else 1\n    sort = {timestamp: sort_order}\n    switch Session.get(\"bl_sort_by\")\n      when \"severity\" then sort = {loglevel: sort_order}\n      when \"source\" then sort = {isServer: sort_order}\n      when \"module\" then sort = {module: sort_order}\n    TLog._getLogs(sort)\n\n#helper to get log level / severity names\n  loglevel_names: (i)->\n      TLog.LOGLEVEL_NAMES[i]\n\n#timestamp formatting helper for the display\n  format_timestamp: (ts)->\n    #console.log \"Formatting date: \" + ts\n    #ts\n    d = new Date(ts)\n    Observatory.viewFormatters._convertDate(d) + ' ' + Observatory.viewFormatters._convertTime(d)\n\n  getUser: (log)->\n    uid = log.uid\n    user = \"\"\n    if uid\n      u = Meteor.users.findOne(uid)\n      if u and u.username\n        user = u.username\n      else\n        if u and u.emails and u.emails[0]\n          user = u.emails[0].address\n        else\n          user = uid\n    else if log.ip then user = log.ip\n    user\n\n\n#applying class to labels showing loglevel / severity\n  lb_loglevel_decoration: ->\n    switch @severity\n      when TLog.LOGLEVEL_FATAL then cl = \"label-fatal\"\n      when TLog.LOGLEVEL_ERROR then cl = \"label-danger\"\n      when TLog.LOGLEVEL_WARNING then cl = \"label-warning\"\n      when TLog.LOGLEVEL_INFO then cl = \"label-primary\"\n      when TLog.LOGLEVEL_DEBUG then cl = \"lb_test_label\"\n      when TLog.LOGLEVEL_VERBOSE then cl = \"label-success\"\n\n\n#apllying class to the message text (<td>) based on loglevel\n  lb_loglevel_msg_decoration: ->\n    switch @severity\n      when TLog.LOGLEVEL_FATAL then cl = \"lb_msg_error\"\n      when TLog.LOGLEVEL_ERROR then cl = \"text-error\"#\"lb_msg_error\"\n      when TLog.LOGLEVEL_WARNING then cl = \"lb_msg_warning\"\n\n#apllying class to the whole log row based on loglevel\n  lb_loglevel_row_decoration: ->\n    # Turning OFF for now as this is needed for the \"light\" scheme\n\n    switch @severity\n      when TLog.LOGLEVEL_FATAL then cl = \"error\"\n      when TLog.LOGLEVEL_ERROR then cl = \"error\"\n      when TLog.LOGLEVEL_WARNING then cl = \"warning\"\n\n# very basic template\n_.extend Template.observatoryjsLogsSimple,\n  log_messages: ->\n    TLog._getLogs()\n"]}